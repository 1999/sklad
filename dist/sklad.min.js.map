{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sklad.min.js","webpack:///webpack/bootstrap ee790cd6451072ad5730","webpack:///./lib/sklad.js","webpack:///./~/kinopromise/build.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","uuid","replace","r","Math","random","v","toString","createError","name","message","errObj","Error","ensureError","err","checkSavedData","dbName","objStore","data","keyValueContainer","prototype","isPrototypeOf","skladKeyValueContainer","objStoreMeta","objStoresMeta","get","undefined","keyPath","autoIncrement","_typeof","checkContainingStores","objStoreNames","every","storeName","indexOf","database","objectStoreNames","getObjStoresMeta","db","dbMeta","promises","forEach","objStoreName","has","promise","Promise","resolve","transaction","TRANSACTION_READWRITE","oncomplete","onabort","objectStore","set","Array","isArray","add","ex","abort","push","all","Symbol","iterator","constructor","KinoPromise","window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","mozIDBTransaction","webkitIDBTransaction","msIDBTransaction","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","IDBCursor","mozIDBCursor","webkitIDBCursor","msIDBCursor","TRANSACTION_READONLY","READ_ONLY","READ_WRITE","skladAPI","ASC","NEXT","ASC_UNIQUE","NEXT_NO_DUPLICATE","DESC","PREV","DESC_UNIQUE","PREV_NO_DUPLICATE","supportsObjStoreGetAll","IDBObjectStore","getAll","getAllKeys","Map","create","skladConnection","insert","_this","isMulti","arguments","length","keys","allObjStoresExist","version","reject","then","result","abortErr","res","onerror","evt","target","error","isSuccess","type","preventDefault","_loop","_loop2","i","checkedData","req","apply","onsuccess","_ret3","_ret2","upsert","_this2","_loop3","_loop4","put","_ret6","_ret5","delete","_this3","map","_loop5","recordKey","clear","_this4","_this5","_loop6","options","direction","range","useGetAll","iterateRequest","index","indexNames","contains","openCursor","_ret10","args","offset","limit","values","resultIndex","cursorPositionMoved","cursor","advance","_ret9","count","_this6","countRequest","_loop7","rangeArgs","_ret12","close","open","openConnRequest","isResolvedOrRejected","onupgradeneeded","migration","oldVersion","newVersion","parseInt","setVersion","changeVerRequest","customUpgradeNeededEvt","Event","source","errorMessage","webkitErrorMessage","mozErrorMessage","msErrorMessage","onblocked","deleteDatabase","openDbRequest","keyValue","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","_toConsumableArray","arr","arr2","from","_createClass","defineProperties","props","descriptor","protoProps","staticProps","_Promise","getPrototypeOf","onFulfilled","onRejected","onFulfilledInternal","isPromisesList","promisesArray","promisesKeys","output","reduce","chunk"],"mappings":"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","file":"sklad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n\t * https://github.com/1999/sklad\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy\n\t * of this software and associated documentation files (the \"Software\"), to deal\n\t * in the Software without restriction, including without limitation the rights\n\t * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t * copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t * THE SOFTWARE.\n\t *\n\t * @author Dmitry Sorin <info@staypositive.ru>\n\t * @license http://www.opensource.org/licenses/mit-license.html MIT License\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar KinoPromise = __webpack_require__(1);\n\t\n\tif (!window.indexedDB) {\n\t    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\t}\n\t\n\tif (!window.IDBTransaction) {\n\t    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n\t}\n\t\n\tif (!window.IDBKeyRange) {\n\t    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n\t}\n\t\n\tif (!window.IDBCursor) {\n\t    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n\t}\n\t\n\tvar TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\n\tvar TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\t\n\tvar skladAPI = {};\n\tskladAPI.ASC = window.IDBCursor.NEXT || 'next';\n\tskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\n\tskladAPI.DESC = window.IDBCursor.PREV || 'prev';\n\tskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\t\n\t// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n\t// into Array.prototype.indexOf with its code\n\tvar indexOf = Array.prototype.indexOf;\n\tvar supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function' && typeof IDBObjectStore.prototype.getAllKeys === 'function';\n\tvar objStoresMeta = new Map();\n\t\n\t/**\n\t * Generates UUIDs for objects without keys set\n\t * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n\t */\n\tfunction uuid() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        var r = Math.random() * 16 | 0;\n\t        var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\n\t        return v.toString(16);\n\t    });\n\t}\n\t\n\tfunction createError(name, message) {\n\t    var errObj = new Error(message);\n\t    errObj.name = name;\n\t\n\t    return errObj;\n\t}\n\t\n\tfunction ensureError(err) {\n\t    if (err instanceof Error) {\n\t        return err;\n\t    }\n\t\n\t    return createError(err.name, err.message);\n\t}\n\t\n\t/**\n\t * Common ancestor for objects created with sklad.keyValue() method\n\t * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n\t */\n\tvar skladKeyValueContainer = Object.create(null);\n\t\n\t/**\n\t * Checks data before saving it in the object store\n\t * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n\t */\n\tfunction checkSavedData(dbName, objStore, data) {\n\t    var keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n\t    var value = keyValueContainer ? data.value : data;\n\t    var objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n\t    var key = keyValueContainer ? data.key : undefined;\n\t\n\t    var keyPath = objStore.keyPath || objStoreMeta.keyPath;\n\t    var autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\t\n\t    if (keyPath === null) {\n\t        if (!autoIncrement && key === undefined) {\n\t            key = uuid();\n\t        }\n\t    } else {\n\t        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n\t            return false;\n\t        }\n\t\n\t        // TODO: support dot-separated and array keyPaths\n\t        if (!autoIncrement && data[keyPath] === undefined) {\n\t            data[keyPath] = uuid();\n\t        }\n\t    }\n\t\n\t    return key ? [value, key] : [value];\n\t}\n\t\n\t/**\n\t * Check whether database contains all needed stores\n\t *\n\t * @param {Array<String>} objStoreNames\n\t * @return {Boolean}\n\t */\n\tfunction checkContainingStores(objStoreNames) {\n\t    return objStoreNames.every(function (storeName) {\n\t        return indexOf.call(this.database.objectStoreNames, storeName) !== -1;\n\t    }, this);\n\t}\n\t\n\t/**\n\t * autoIncrement is broken in IE family. Run this transaction to get its value\n\t * on every object store\n\t *\n\t * @param {IDBDatabase} db\n\t * @param {Array<String>} objStoreNames\n\t * @return {Promise}\n\t *\n\t * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined\n\t * @see https://connect.microsoft.com/IE/Feedback/Details/772726\n\t */\n\tfunction getObjStoresMeta(db, objStoreNames) {\n\t    var dbMeta = objStoresMeta.get(db.name);\n\t    var promises = [];\n\t\n\t    objStoreNames.forEach(function (objStoreName) {\n\t        if (dbMeta.has(objStoreName)) {\n\t            return;\n\t        }\n\t\n\t        var promise = new Promise(function (resolve) {\n\t            var transaction = db.transaction([objStoreName], TRANSACTION_READWRITE);\n\t            transaction.oncomplete = resolve;\n\t            transaction.onabort = resolve;\n\t\n\t            var objStore = transaction.objectStore(objStoreName);\n\t\n\t            if (objStore.autoIncrement !== undefined) {\n\t                dbMeta.set(objStoreName, {\n\t                    autoIncrement: objStore.autoIncrement,\n\t                    keyPath: objStore.keyPath\n\t                });\n\t\n\t                return;\n\t            }\n\t\n\t            var autoIncrement = void 0;\n\t\n\t            if (objStore.keyPath !== null) {\n\t                // if key path is defined it's possible to insert only objects\n\t                // but if key generator (autoIncrement) is not defined the inserted objects\n\t                // must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails\n\t                // so if we run ODBObjectStore.add with an empty object and it fails, this means that\n\t                // autoIncrement property was false. Otherwise - true\n\t                // if key path is array autoIncrement property can't be true\n\t                if (Array.isArray(objStore.keyPath)) {\n\t                    autoIncrement = false;\n\t                } else {\n\t                    try {\n\t                        objStore.add({});\n\t                        autoIncrement = true;\n\t                    } catch (ex) {\n\t                        autoIncrement = false;\n\t                    }\n\t                }\n\t            } else {\n\t                // if key path is not defined it's possible to insert any kind of data\n\t                // but if key generator (autoIncrement) is not defined you should set it explicitly\n\t                // so if we run ODBObjectStore.add with one argument and it fails, this means that\n\t                // autoIncrement property was false. Otherwise - true\n\t                try {\n\t                    objStore.add('some value');\n\t                    autoIncrement = true;\n\t                } catch (ex) {\n\t                    autoIncrement = false;\n\t                }\n\t            }\n\t\n\t            // save meta properties\n\t            dbMeta.set(objStoreName, {\n\t                autoIncrement: autoIncrement,\n\t                keyPath: objStore.keyPath\n\t            });\n\t\n\t            // and abort transaction so that new record is forgotten\n\t            transaction.abort();\n\t        });\n\t\n\t        promises.push(promise);\n\t    });\n\t\n\t    return Promise.all(promises);\n\t}\n\t\n\tvar skladConnection = {\n\t    /**\n\t     * 1) Insert one record into the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {*} inserted object key\n\t     *\n\t     * 2) Insert multiple records into the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} inserted objects' keys\n\t     */\n\t    insert: function skladConnection_insert() {\n\t        var _this = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return getObjStoresMeta(this.database, objStoreNames).then(function () {\n\t            return new Promise(function (resolve, reject) {\n\t                var result = {};\n\t                var transaction = void 0;\n\t                var abortErr = void 0;\n\t\n\t                // Safari9 can't run multi-objectstore transactions\n\t                // divide one transaction into many with one object store to fix this\n\t                try {\n\t                    transaction = _this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t                } catch (ex) {\n\t                    if (ex.name === 'NotFoundError') {\n\t                        (function () {\n\t                            var promises = {};\n\t\n\t                            objStoreNames.forEach(function (objStoreName) {\n\t                                var promise = _this.insert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {\n\t                                    return res[objStoreName];\n\t                                });\n\t\n\t                                promises[objStoreName] = promise;\n\t                            });\n\t\n\t                            KinoPromise.all(promises).then(resolve).catch(reject);\n\t                        })();\n\t                    } else {\n\t                        reject(ex);\n\t                    }\n\t\n\t                    return;\n\t                }\n\t\n\t                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n\t                    var err = abortErr || evt.target.error;\n\t                    var isSuccess = !err && evt.type === 'complete';\n\t\n\t                    if (isSuccess) {\n\t                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                    } else {\n\t                        reject(ensureError(err));\n\t                    }\n\t\n\t                    if (evt.type === 'error') {\n\t                        evt.preventDefault();\n\t                    }\n\t                };\n\t\n\t                var _loop = function _loop(objStoreName) {\n\t                    var objStore = transaction.objectStore(objStoreName);\n\t\n\t                    var _loop2 = function _loop2(i) {\n\t                        var checkedData = checkSavedData(_this.database.name, objStore, data[objStoreName][i]);\n\t\n\t                        if (!checkedData) {\n\t                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t\n\t                        var req = void 0;\n\t                        try {\n\t                            req = objStore.add.apply(objStore, checkedData);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return 'continue';\n\t                        }\n\t\n\t                        req.onsuccess = function (evt) {\n\t                            result[objStoreName] = result[objStoreName] || [];\n\t                            result[objStoreName][i] = evt.target.result;\n\t                        };\n\t                    };\n\t\n\t                    for (var i = 0; i < data[objStoreName].length; i++) {\n\t                        var _ret3 = _loop2(i);\n\t\n\t                        switch (_ret3) {\n\t                            case 'continue':\n\t                                continue;\n\t\n\t                            default:\n\t                                if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n\t                        }\n\t                    }\n\t                };\n\t\n\t                for (var objStoreName in data) {\n\t                    var _ret2 = _loop(objStoreName);\n\t\n\t                    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Insert or update one record in the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {*} inserted/updated object key otherwise\n\t     *\n\t     * 2) Insert or update multiple records in the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} inserted/updated objects' keys otherwise\n\t     */\n\t    upsert: function skladConnection_upsert() {\n\t        var _this2 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return getObjStoresMeta(this.database, objStoreNames).then(function () {\n\t            return new Promise(function (resolve, reject) {\n\t                var result = {};\n\t                var transaction = void 0;\n\t                var abortErr = void 0;\n\t\n\t                // Safari9 can't run multi-objectstore transactions\n\t                // divide one transaction into many with one object store to fix this\n\t                try {\n\t                    transaction = _this2.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t                } catch (ex) {\n\t                    if (ex.name === 'NotFoundError') {\n\t                        (function () {\n\t                            var promises = {};\n\t\n\t                            objStoreNames.forEach(function (objStoreName) {\n\t                                var promise = _this2.upsert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {\n\t                                    return res[objStoreName];\n\t                                });\n\t\n\t                                promises[objStoreName] = promise;\n\t                            });\n\t\n\t                            KinoPromise.all(promises).then(resolve).catch(reject);\n\t                        })();\n\t                    } else {\n\t                        reject(ex);\n\t                    }\n\t\n\t                    return;\n\t                }\n\t\n\t                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n\t                    var err = abortErr || evt.target.error;\n\t                    var isSuccess = !err && evt.type === 'complete';\n\t\n\t                    if (isSuccess) {\n\t                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                    } else {\n\t                        reject(ensureError(err));\n\t                    }\n\t\n\t                    if (evt.type === 'error') {\n\t                        evt.preventDefault();\n\t                    }\n\t                };\n\t\n\t                var _loop3 = function _loop3(objStoreName) {\n\t                    var objStore = transaction.objectStore(objStoreName);\n\t\n\t                    var _loop4 = function _loop4(i) {\n\t                        var checkedData = checkSavedData(_this2.database.name, objStore, data[objStoreName][i]);\n\t\n\t                        if (!checkedData) {\n\t                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t\n\t                        var req = void 0;\n\t                        try {\n\t                            req = objStore.put.apply(objStore, checkedData);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return 'continue';\n\t                        }\n\t\n\t                        req.onsuccess = function (evt) {\n\t                            result[objStoreName] = result[objStoreName] || [];\n\t                            result[objStoreName][i] = evt.target.result;\n\t                        };\n\t                    };\n\t\n\t                    for (var i = 0; i < data[objStoreName].length; i++) {\n\t                        var _ret6 = _loop4(i);\n\t\n\t                        switch (_ret6) {\n\t                            case 'continue':\n\t                                continue;\n\t\n\t                            default:\n\t                                if ((typeof _ret6 === 'undefined' ? 'undefined' : _typeof(_ret6)) === \"object\") return _ret6.v;\n\t                        }\n\t                    }\n\t                };\n\t\n\t                for (var objStoreName in data) {\n\t                    var _ret5 = _loop3(objStoreName);\n\t\n\t                    if ((typeof _ret5 === 'undefined' ? 'undefined' : _typeof(_ret5)) === \"object\") return _ret5.v;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Delete one record from the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Mixed} key\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *\n\t     * 2) Delete multiple records from the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *\n\t     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n\t     */\n\t    delete: function skladConnection_delete() {\n\t        var _this3 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this3.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    var promises = objStoreNames.map(function (objStoreName) {\n\t                        return _this3.delete(objStoreName, data[objStoreName]);\n\t                    });\n\t                    Promise.all(promises).then(function () {\n\t                        return resolve();\n\t                    }).catch(reject);\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject(ensureError(err));\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop5 = function _loop5(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                data[objStoreName].forEach(function (recordKey) {\n\t                    if (abortErr) {\n\t                        return;\n\t                    }\n\t\n\t                    try {\n\t                        objStore.delete(recordKey);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                    }\n\t                });\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                _loop5(objStoreName);\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Clear object store(s)\n\t     *\n\t     * @param {Array|String} objStoreNames array of object stores or a single object store\n\t     * @return {Promise}\n\t     *   @param {Error} err\n\t     */\n\t    clear: function skladConnection_clear(objStoreNames) {\n\t        var _this4 = this;\n\t\n\t        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this4.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    var promises = objStoreNames.map(function (objStoreName) {\n\t                        return _this4.clear([objStoreName]);\n\t                    });\n\t                    Promise.all(promises).then(function () {\n\t                        return resolve();\n\t                    }).catch(reject);\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject(ensureError(err));\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            objStoreNames.forEach(function (objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                if (abortErr) {\n\t                    return;\n\t                }\n\t\n\t                try {\n\t                    objStore.clear();\n\t                } catch (ex) {\n\t                    abortErr = ex;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Get objects from one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Array} stored objects otherwise\n\t     *\n\t     * 2) Get objects from multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} stored objects otherwise\n\t     */\n\t    get: function skladConnection_get() {\n\t        var _this5 = this;\n\t\n\t        var isMulti = arguments.length === 2 && _typeof(arguments[0]) === 'object' && typeof arguments[1] === 'function';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var result = {};\n\t        var data = void 0,\n\t            abortErr = void 0;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        objStoreNames.forEach(function (objStoreName) {\n\t            result[objStoreName] = [];\n\t        });\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this5.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    (function () {\n\t                        var promises = {};\n\t\n\t                        objStoreNames.forEach(function (objStoreName) {\n\t                            var promise = _this5.get(objStoreName, data[objStoreName]);\n\t                            promises[objStoreName] = promise;\n\t                        });\n\t\n\t                        KinoPromise.all(promises).then(resolve).catch(reject);\n\t                    })();\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject(ensureError(err));\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop6 = function _loop6(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var direction = options.direction || skladAPI.ASC;\n\t                var range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\t\n\t                var useGetAll = false;\n\t                var iterateRequest = void 0;\n\t\n\t                if (supportsObjStoreGetAll) {\n\t                    // getAll doesn't work for index ranges + it doesn't support special directions\n\t                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n\t                    useGetAll = Object.keys(options).every(function (key) {\n\t                        return key !== 'index' && key !== 'direction';\n\t                    });\n\t                }\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = createError('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                } else if (useGetAll) {\n\t                    var _ret10 = function () {\n\t                        // If browser supports getAll/getAllKeys methods it could be faster to run these methods\n\t                        // to get all records if there's no `index` or `direction` options set\n\t                        // Unfortunately getAll doesn't expose result keys so we have to run both these methods\n\t                        // to get all keys and values\n\t                        // Anyway it seems like 2 getAll* ops are faster in modern browsers than that one\n\t                        // working with UDBCursor\n\t                        //\n\t                        // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n\t                        // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAllKeys\n\t                        // @see http://jsperf.com/idb-idbcursor-vs-idbobjectstore-getall-ops/3\n\t                        var args = [range];\n\t                        var offset = 0;\n\t\n\t                        if (options.limit) {\n\t                            args.push(options.limit);\n\t\n\t                            if (options.offset) {\n\t                                args[1] += options.offset;\n\t                                offset = options.offset;\n\t                            }\n\t                        }\n\t\n\t                        try {\n\t                            // get all values request\n\t                            objStore.getAll.apply(objStore, args).onsuccess = function (evt) {\n\t                                var values = evt.target.result;\n\t\n\t                                values.forEach(function (value, index) {\n\t                                    if (index < offset) {\n\t                                        return;\n\t                                    }\n\t\n\t                                    var resultIndex = index - offset;\n\t                                    result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n\t                                    result[objStoreName][resultIndex].value = value;\n\t                                });\n\t                            };\n\t\n\t                            // get all keys request\n\t                            objStore.getAllKeys.apply(objStore, args).onsuccess = function (evt) {\n\t                                var keys = evt.target.result;\n\t\n\t                                keys.forEach(function (key, index) {\n\t                                    if (index < offset) {\n\t                                        return;\n\t                                    }\n\t\n\t                                    var resultIndex = index - offset;\n\t                                    result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n\t                                    result[objStoreName][resultIndex].key = key;\n\t                                });\n\t                            };\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                        } finally {\n\t                            // there are 2 separate IDBRequests running\n\t                            // so there's no need to bind listener to success event of any of them\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t                    }();\n\t\n\t                    if ((typeof _ret10 === 'undefined' ? 'undefined' : _typeof(_ret10)) === \"object\") return _ret10.v;\n\t                } else {\n\t                    try {\n\t                        iterateRequest = objStore.openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                }\n\t\n\t                var cursorPositionMoved = false;\n\t\n\t                iterateRequest.onsuccess = function (evt) {\n\t                    var cursor = evt.target.result;\n\t\n\t                    // no more results\n\t                    if (!cursor) {\n\t                        return;\n\t                    }\n\t\n\t                    if (options.offset && !cursorPositionMoved) {\n\t                        cursorPositionMoved = true;\n\t                        cursor.advance(options.offset);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    result[objStoreName].push({\n\t                        key: cursor.key,\n\t                        value: cursor.value\n\t                    });\n\t\n\t                    if (options.limit && options.limit === result[objStoreName].length) {\n\t                        return;\n\t                    }\n\t\n\t                    cursor.continue();\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret9 = _loop6(objStoreName);\n\t\n\t                if ((typeof _ret9 === 'undefined' ? 'undefined' : _typeof(_ret9)) === \"object\") return _ret9.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Count objects in one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Number} number of stored objects otherwise\n\t     *\n\t     * 2) Count objects in multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} number of stored objects otherwise\n\t     */\n\t    count: function skladConnection_count() {\n\t        var _this6 = this;\n\t\n\t        var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t        var data = void 0;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var result = {};\n\t            var transaction = void 0;\n\t            var countRequest = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this6.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    (function () {\n\t                        var promises = {};\n\t\n\t                        objStoreNames.forEach(function (objStoreName) {\n\t                            var promise = _this6.count(objStoreName, data[objStoreName]);\n\t                            promises[objStoreName] = promise;\n\t                        });\n\t\n\t                        KinoPromise.all(promises).then(resolve).catch(reject);\n\t                    })();\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject(ensureError(err));\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop7 = function _loop7(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var rangeArgs = options.range instanceof window.IDBKeyRange ? [options.range] : [];\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = createError('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        var index = objStore.index(options.index);\n\t                        countRequest = index.count.apply(index, rangeArgs);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                } else {\n\t                    try {\n\t                        countRequest = objStore.count.apply(objStore, rangeArgs);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                }\n\t\n\t                countRequest.onsuccess = function (evt) {\n\t                    result[objStoreName] = evt.target.result || 0;\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret12 = _loop7(objStoreName);\n\t\n\t                if ((typeof _ret12 === 'undefined' ? 'undefined' : _typeof(_ret12)) === \"object\") return _ret12.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Close IndexedDB connection\n\t     */\n\t    close: function skladConnection_close() {\n\t        this.database.close();\n\t        delete this.database;\n\t    }\n\t};\n\t\n\t/**\n\t * Opens connection to a database\n\t *\n\t * @param {String} dbName database name\n\t * @param {Object} [options = {}] connection options\n\t * @param {Number} [options.version] database version\n\t * @param {Object} [options.migration] migration scripts\n\t * @return {Promise}\n\t *   @param {Object} [conn] if - promise is resolved\n\t *   @param {Error} [err] - if promise is rejected\n\t */\n\tskladAPI.open = function sklad_open(dbName) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? { version: 1 } : arguments[1];\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openConnRequest = window.indexedDB.open(dbName, options.version);\n\t        var isResolvedOrRejected = false;\n\t\n\t        openConnRequest.onupgradeneeded = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            options.migration = options.migration || {};\n\t            for (var i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n\t                if (!options.migration[i]) continue;\n\t\n\t                options.migration[i].call(this, this.result);\n\t            }\n\t        };\n\t\n\t        openConnRequest.onerror = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t            reject(ensureError(evt.target.error));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onsuccess = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            var database = this.result;\n\t            var oldVersion = parseInt(database.version || 0, 10);\n\t\n\t            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n\t                var changeVerRequest = database.setVersion(options.version);\n\t\n\t                changeVerRequest.onsuccess = function (evt) {\n\t                    var customUpgradeNeededEvt = new Event('upgradeneeded');\n\t                    customUpgradeNeededEvt.oldVersion = oldVersion;\n\t                    customUpgradeNeededEvt.newVersion = options.version;\n\t                    openConnRequest.onupgradeneeded.call({ result: evt.target.source }, customUpgradeNeededEvt);\n\t\n\t                    database.close();\n\t                    skladAPI.open(dbName, options).then(resolve, reject);\n\t                };\n\t\n\t                changeVerRequest.onerror = function (evt) {\n\t                    var err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n\t                    reject(ensureError(err));\n\t                };\n\t\n\t                return;\n\t            }\n\t\n\t            // store object stores properties in their own map\n\t            objStoresMeta.set(dbName, new Map());\n\t\n\t            resolve(Object.create(skladConnection, {\n\t                database: {\n\t                    configurable: true,\n\t                    enumerable: false,\n\t                    value: database,\n\t                    writable: false\n\t                }\n\t            }));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onblocked = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t\n\t            reject(createError('InvalidStateError', 'Database ' + dbName + ' is blocked'));\n\t            isResolvedOrRejected = true;\n\t        };\n\t    });\n\t};\n\t\n\t/**\n\t * Deletes database\n\t *\n\t * @param {String} dbName\n\t * @return {Promise}\n\t *   @param {Error} [err] if promise is rejected\n\t */\n\tskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\t\n\t        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n\t            var err = evt.type === 'blocked' ? createError('InvalidStateError', 'Database ' + dbName + ' is blocked') : evt.target.error;\n\t\n\t            if (err) {\n\t                reject(ensureError(err));\n\t            } else {\n\t                resolve();\n\t            }\n\t\n\t            if (evt.type !== 'success') {\n\t                evt.preventDefault();\n\t            }\n\t        };\n\t    });\n\t};\n\t\n\tskladAPI.keyValue = function sklad_keyValue(key, value) {\n\t    return Object.create(skladKeyValueContainer, {\n\t        key: { value: key, configurable: false, writable: false },\n\t        value: { value: value, configurable: false, writable: false }\n\t    });\n\t};\n\t\n\texports.default = skladAPI;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _toConsumableArray(arr) {\n\t    if (Array.isArray(arr)) {\n\t        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t            arr2[i] = arr[i];\n\t        }return arr2;\n\t    } else {\n\t        return Array.from(arr);\n\t    }\n\t}\n\t\n\tvar KinoPromise = function (_Promise) {\n\t    _inherits(KinoPromise, _Promise);\n\t\n\t    function KinoPromise() {\n\t        _classCallCheck(this, KinoPromise);\n\t\n\t        return _possibleConstructorReturn(this, Object.getPrototypeOf(KinoPromise).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(KinoPromise, [{\n\t        key: 'spread',\n\t        value: function spread(onFulfilled, onRejected) {\n\t            function onFulfilledInternal(res) {\n\t                if (Array.isArray(res)) {\n\t                    return onFulfilled.apply(undefined, _toConsumableArray(res));\n\t                }\n\t            };\n\t\n\t            return this.then(onFulfilledInternal, onRejected);\n\t        }\n\t    }]);\n\t\n\t    return KinoPromise;\n\t}(Promise);\n\t\n\tKinoPromise.all = function KinoPromise_static_all(promises) {\n\t    if (arguments.length > 1 || (typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) !== 'object') {\n\t        return Promise.all.apply(Promise, arguments);\n\t    }\n\t\n\t    return new KinoPromise(function (resolve, reject) {\n\t        var isPromisesList = Array.isArray(promises);\n\t        var promisesArray = void 0;\n\t        var promisesKeys = void 0;\n\t\n\t        if (isPromisesList) {\n\t            promisesArray = promises;\n\t        } else {\n\t            promisesKeys = Object.keys(promises);\n\t            promisesArray = promisesKeys.map(function (key) {\n\t                return promises[key];\n\t            });\n\t        }\n\t\n\t        Promise.all(promisesArray).then(function (res) {\n\t            // transform output into an object\n\t            var output = void 0;\n\t\n\t            if (isPromisesList) {\n\t                output = res;\n\t            } else {\n\t                output = res.reduce(function (output, chunk, index) {\n\t                    output[promisesKeys[index]] = chunk;\n\t                    return output;\n\t                }, {});\n\t            }\n\t\n\t            resolve(output);\n\t        }).catch(reject);\n\t    });\n\t};\n\t\n\texports.default = KinoPromise;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** sklad.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ee790cd6451072ad5730\n **/","/**\n * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n * https://github.com/1999/sklad\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author Dmitry Sorin <info@staypositive.ru>\n * @license http://www.opensource.org/licenses/mit-license.html MIT License\n */\n'use strict';\n\nconst KinoPromise = require('kinopromise');\n\nif (!window.indexedDB) {\n    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n}\n\nif (!window.IDBTransaction) {\n    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n}\n\nif (!window.IDBKeyRange) {\n    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n}\n\nif (!window.IDBCursor) {\n    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n}\n\nconst TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\nconst TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\nconst skladAPI = {};\nskladAPI.ASC = window.IDBCursor.NEXT || 'next';\nskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\nskladAPI.DESC = window.IDBCursor.PREV || 'prev';\nskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\n// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n// into Array.prototype.indexOf with its code\nconst indexOf = Array.prototype.indexOf;\nconst supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function' && typeof IDBObjectStore.prototype.getAllKeys === 'function';\nconst objStoresMeta = new Map();\n\n/**\n * Generates UUIDs for objects without keys set\n * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n */\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = (c === 'x') ? r : (r&0x3|0x8);\n\n        return v.toString(16);\n    });\n}\n\nfunction createError(name, message) {\n    const errObj = new Error(message);\n    errObj.name = name;\n\n    return errObj;\n}\n\nfunction ensureError(err) {\n    if (err instanceof Error) {\n        return err;\n    }\n\n    return createError(err.name, err.message);\n}\n\n/**\n * Common ancestor for objects created with sklad.keyValue() method\n * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n */\nconst skladKeyValueContainer = Object.create(null);\n\n/**\n * Checks data before saving it in the object store\n * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n */\nfunction checkSavedData(dbName, objStore, data) {\n    const keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n    const value = keyValueContainer ? data.value : data;\n    const objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n    let key = keyValueContainer ? data.key : undefined;\n\n    const keyPath = objStore.keyPath || objStoreMeta.keyPath;\n    const autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\n    if (keyPath === null) {\n        if (!autoIncrement && key === undefined) {\n            key = uuid();\n        }\n    } else {\n        if (typeof data !== 'object') {\n            return false;\n        }\n\n        // TODO: support dot-separated and array keyPaths\n        if (!autoIncrement && data[keyPath] === undefined) {\n            data[keyPath] = uuid();\n        }\n    }\n\n    return key ? [value, key] : [value];\n}\n\n/**\n * Check whether database contains all needed stores\n *\n * @param {Array<String>} objStoreNames\n * @return {Boolean}\n */\nfunction checkContainingStores(objStoreNames) {\n    return objStoreNames.every(function (storeName) {\n        return (indexOf.call(this.database.objectStoreNames, storeName) !== -1);\n    }, this);\n}\n\n/**\n * autoIncrement is broken in IE family. Run this transaction to get its value\n * on every object store\n *\n * @param {IDBDatabase} db\n * @param {Array<String>} objStoreNames\n * @return {Promise}\n *\n * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined\n * @see https://connect.microsoft.com/IE/Feedback/Details/772726\n */\nfunction getObjStoresMeta(db, objStoreNames) {\n    const dbMeta = objStoresMeta.get(db.name);\n    const promises = [];\n\n    objStoreNames.forEach(objStoreName => {\n        if (dbMeta.has(objStoreName)) {\n            return;\n        }\n\n        const promise = new Promise(resolve => {\n            const transaction = db.transaction([objStoreName], TRANSACTION_READWRITE);\n            transaction.oncomplete = resolve;\n            transaction.onabort = resolve;\n\n            const objStore = transaction.objectStore(objStoreName);\n\n            if (objStore.autoIncrement !== undefined) {\n                dbMeta.set(objStoreName, {\n                    autoIncrement: objStore.autoIncrement,\n                    keyPath: objStore.keyPath\n                });\n\n                return;\n            }\n\n            let autoIncrement;\n\n            if (objStore.keyPath !== null) {\n                // if key path is defined it's possible to insert only objects\n                // but if key generator (autoIncrement) is not defined the inserted objects\n                // must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails\n                // so if we run ODBObjectStore.add with an empty object and it fails, this means that\n                // autoIncrement property was false. Otherwise - true\n                // if key path is array autoIncrement property can't be true\n                if (Array.isArray(objStore.keyPath)) {\n                    autoIncrement = false;\n                } else {\n                    try {\n                        objStore.add({});\n                        autoIncrement = true;\n                    } catch (ex) {\n                        autoIncrement = false;\n                    }\n                }\n            } else {\n                // if key path is not defined it's possible to insert any kind of data\n                // but if key generator (autoIncrement) is not defined you should set it explicitly\n                // so if we run ODBObjectStore.add with one argument and it fails, this means that\n                // autoIncrement property was false. Otherwise - true\n                try {\n                    objStore.add('some value');\n                    autoIncrement = true;\n                } catch (ex) {\n                    autoIncrement = false;\n                }\n            }\n\n            // save meta properties\n            dbMeta.set(objStoreName, {\n                autoIncrement: autoIncrement,\n                keyPath: objStore.keyPath\n            });\n\n            // and abort transaction so that new record is forgotten\n            transaction.abort();\n        });\n\n        promises.push(promise);\n    });\n\n    return Promise.all(promises);\n}\n\nconst skladConnection = {\n    /**\n     * 1) Insert one record into the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {*} inserted object key\n     *\n     * 2) Insert multiple records into the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} inserted objects' keys\n     */\n    insert: function skladConnection_insert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return getObjStoresMeta(this.database, objStoreNames).then(() => {\n            return new Promise((resolve, reject) => {\n                const result = {};\n                let transaction;\n                let abortErr;\n\n                // Safari9 can't run multi-objectstore transactions\n                // divide one transaction into many with one object store to fix this\n                try {\n                    transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n                } catch (ex) {\n                    if (ex.name === 'NotFoundError') {\n                        const promises = {};\n\n                        objStoreNames.forEach(objStoreName => {\n                            const promise = this.insert({\n                                [objStoreName]: Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]]\n                            }).then(res => res[objStoreName]);\n\n                            promises[objStoreName] = promise;\n                        });\n\n                        KinoPromise.all(promises).then(resolve).catch(reject);\n                    } else {\n                        reject(ex);\n                    }\n\n                    return;\n                }\n\n                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n                    const err = abortErr || evt.target.error;\n                    const isSuccess = !err && evt.type === 'complete';\n\n                    if (isSuccess) {\n                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                    } else {\n                        reject(ensureError(err));\n                    }\n\n                    if (evt.type === 'error') {\n                        evt.preventDefault();\n                    }\n                };\n\n                for (let objStoreName in data) {\n                    const objStore = transaction.objectStore(objStoreName);\n\n                    for (let i = 0; i < data[objStoreName].length; i++) {\n                        const checkedData = checkSavedData(this.database.name, objStore, data[objStoreName][i]);\n\n                        if (!checkedData) {\n                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                            return;\n                        }\n\n                        let req;\n                        try {\n                            req = objStore.add.apply(objStore, checkedData);\n                        } catch (ex) {\n                            abortErr = ex;\n                            continue;\n                        }\n\n                        req.onsuccess = function (evt) {\n                            result[objStoreName] = result[objStoreName] || [];\n                            result[objStoreName][i] = evt.target.result;\n                        };\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Insert or update one record in the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {*} inserted/updated object key otherwise\n     *\n     * 2) Insert or update multiple records in the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} inserted/updated objects' keys otherwise\n     */\n    upsert: function skladConnection_upsert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return getObjStoresMeta(this.database, objStoreNames).then(() => {\n            return new Promise((resolve, reject) => {\n                const result = {};\n                let transaction;\n                let abortErr;\n\n                // Safari9 can't run multi-objectstore transactions\n                // divide one transaction into many with one object store to fix this\n                try {\n                    transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n                } catch (ex) {\n                    if (ex.name === 'NotFoundError') {\n                        const promises = {};\n\n                        objStoreNames.forEach(objStoreName => {\n                            const promise = this.upsert({\n                                [objStoreName]: Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]]\n                            }).then(res => res[objStoreName]);\n\n                            promises[objStoreName] = promise;\n                        });\n\n                        KinoPromise.all(promises).then(resolve).catch(reject);\n                    } else {\n                        reject(ex);\n                    }\n\n                    return;\n                }\n\n                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n                    const err = abortErr || evt.target.error;\n                    const isSuccess = !err && evt.type === 'complete';\n\n                    if (isSuccess) {\n                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                    } else {\n                        reject(ensureError(err));\n                    }\n\n                    if (evt.type === 'error') {\n                        evt.preventDefault();\n                    }\n                };\n\n                for (let objStoreName in data) {\n                    const objStore = transaction.objectStore(objStoreName);\n\n                    for (let i = 0; i < data[objStoreName].length; i++) {\n                        const checkedData = checkSavedData(this.database.name, objStore, data[objStoreName][i]);\n\n                        if (!checkedData) {\n                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                            return;\n                        }\n\n                        let req;\n                        try {\n                            req = objStore.put.apply(objStore, checkedData);\n                        } catch (ex) {\n                            abortErr = ex;\n                            continue;\n                        }\n\n                        req.onsuccess = function (evt) {\n                            result[objStoreName] = result[objStoreName] || [];\n                            result[objStoreName][i] = evt.target.result;\n                        };\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Delete one record from the object store\n     * @param {String} objStoreName name of object store\n     * @param {Mixed} key\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *\n     * 2) Delete multiple records from the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *\n     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n     */\n    delete: function skladConnection_delete() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = objStoreNames.map(objStoreName => this.delete(objStoreName, data[objStoreName]));\n                    Promise.all(promises).then(() => resolve()).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(ensureError(err));\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n\n                data[objStoreName].forEach(recordKey => {\n                    if (abortErr) {\n                        return;\n                    }\n\n                    try {\n                        objStore.delete(recordKey);\n                    } catch (ex) {\n                        abortErr = ex;\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Clear object store(s)\n     *\n     * @param {Array|String} objStoreNames array of object stores or a single object store\n     * @return {Promise}\n     *   @param {Error} err\n     */\n    clear: function skladConnection_clear(objStoreNames) {\n        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = objStoreNames.map(objStoreName => this.clear([objStoreName]));\n                    Promise.all(promises).then(() => resolve()).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(ensureError(err));\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            objStoreNames.forEach(objStoreName => {\n                const objStore = transaction.objectStore(objStoreName);\n\n                if (abortErr) {\n                    return;\n                }\n\n                try {\n                    objStore.clear();\n                } catch (ex) {\n                    abortErr = ex;\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Get objects from one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Array} stored objects otherwise\n     *\n     * 2) Get objects from multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} stored objects otherwise\n     */\n    get: function skladConnection_get() {\n        const isMulti = (arguments.length === 2 && typeof arguments[0] === 'object' && typeof arguments[1] === 'function');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let result = {};\n        let data, abortErr;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        objStoreNames.forEach(function (objStoreName) {\n            result[objStoreName] = [];\n        });\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = {};\n\n                    objStoreNames.forEach(objStoreName => {\n                        const promise = this.get(objStoreName, data[objStoreName]);\n                        promises[objStoreName] = promise;\n                    });\n\n                    KinoPromise.all(promises).then(resolve).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]]);\n                } else {\n                    reject(ensureError(err));\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const direction = options.direction || skladAPI.ASC;\n                const range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\n                let useGetAll = false;\n                let iterateRequest;\n\n                if (supportsObjStoreGetAll) {\n                    // getAll doesn't work for index ranges + it doesn't support special directions\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    useGetAll = Object.keys(options).every(key => (key !== 'index' && key !== 'direction'));\n                }\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else if (useGetAll) {\n                    // If browser supports getAll/getAllKeys methods it could be faster to run these methods\n                    // to get all records if there's no `index` or `direction` options set\n                    // Unfortunately getAll doesn't expose result keys so we have to run both these methods\n                    // to get all keys and values\n                    // Anyway it seems like 2 getAll* ops are faster in modern browsers than that one\n                    // working with UDBCursor\n                    //\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAllKeys\n                    // @see http://jsperf.com/idb-idbcursor-vs-idbobjectstore-getall-ops/3\n                    const args = [range];\n                    let offset = 0;\n\n                    if (options.limit) {\n                        args.push(options.limit);\n\n                        if (options.offset) {\n                            args[1] += options.offset;\n                            offset = options.offset;\n                        }\n                    }\n\n                    try {\n                        // get all values request\n                        objStore.getAll(...args).onsuccess = function (evt) {\n                            const values = evt.target.result;\n\n                            values.forEach((value, index) => {\n                                if (index < offset) {\n                                    return;\n                                }\n\n                                const resultIndex = index - offset;\n                                result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n                                result[objStoreName][resultIndex].value = value;\n                            });\n                        };\n\n                        // get all keys request\n                        objStore.getAllKeys(...args).onsuccess = function (evt) {\n                            const keys = evt.target.result;\n\n                            keys.forEach((key, index) => {\n                                if (index < offset) {\n                                    return;\n                                }\n\n                                const resultIndex = index - offset;\n                                result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n                                result[objStoreName][resultIndex].key = key;\n                            });\n                        };\n                    } catch (ex) {\n                        abortErr = ex;\n                    } finally {\n                        // there are 2 separate IDBRequests running\n                        // so there's no need to bind listener to success event of any of them\n                        return;\n                    }\n                } else {\n                    try {\n                        iterateRequest = objStore.openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                let cursorPositionMoved = false;\n\n                iterateRequest.onsuccess = function (evt) {\n                    const cursor = evt.target.result;\n\n                    // no more results\n                    if (!cursor) {\n                        return;\n                    }\n\n                    if (options.offset && !cursorPositionMoved) {\n                        cursorPositionMoved = true;\n                        cursor.advance(options.offset);\n\n                        return;\n                    }\n\n                    result[objStoreName].push({\n                        key: cursor.key,\n                        value: cursor.value\n                    });\n\n                    if (options.limit && options.limit === result[objStoreName].length) {\n                        return;\n                    }\n\n                    cursor.continue();\n                };\n            }\n        });\n    },\n\n    /**\n     * 1) Count objects in one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Number} number of stored objects otherwise\n     *\n     * 2) Count objects in multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} number of stored objects otherwise\n     */\n    count: function skladConnection_count() {\n        const isMulti = (arguments.length === 1 && typeof arguments[0] === 'object');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n        let data;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            const result = {};\n            let transaction;\n            let countRequest;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = {};\n\n                    objStoreNames.forEach(objStoreName => {\n                        const promise = this.count(objStoreName, data[objStoreName]);\n                        promises[objStoreName] = promise;\n                    });\n\n                    KinoPromise.all(promises).then(resolve).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]])\n                } else {\n                    reject(ensureError(err));\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const rangeArgs = (options.range instanceof window.IDBKeyRange) ? [options.range] : [];\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        const index = objStore.index(options.index);\n                        countRequest = index.count(...rangeArgs);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else {\n                    try {\n                        countRequest = objStore.count(...rangeArgs);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                countRequest.onsuccess = function (evt) {\n                    result[objStoreName] = evt.target.result || 0;\n                };\n            }\n        });\n    },\n\n    /**\n     * Close IndexedDB connection\n     */\n    close: function skladConnection_close() {\n        this.database.close();\n        delete this.database;\n    }\n};\n\n/**\n * Opens connection to a database\n *\n * @param {String} dbName database name\n * @param {Object} [options = {}] connection options\n * @param {Number} [options.version] database version\n * @param {Object} [options.migration] migration scripts\n * @return {Promise}\n *   @param {Object} [conn] if - promise is resolved\n *   @param {Error} [err] - if promise is rejected\n */\nskladAPI.open = function sklad_open(dbName, options = {version: 1}) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openConnRequest = window.indexedDB.open(dbName, options.version);\n        let isResolvedOrRejected = false;\n\n        openConnRequest.onupgradeneeded = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            options.migration = options.migration || {};\n            for (let i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n                if (!options.migration[i])\n                    continue;\n\n                options.migration[i].call(this, this.result);\n            }\n        };\n\n        openConnRequest.onerror = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n            reject(ensureError(evt.target.error));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onsuccess = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            const database = this.result;\n            const oldVersion = parseInt(database.version || 0, 10);\n\n            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n                const changeVerRequest = database.setVersion(options.version);\n\n                changeVerRequest.onsuccess = function (evt) {\n                    const customUpgradeNeededEvt = new Event('upgradeneeded');\n                    customUpgradeNeededEvt.oldVersion = oldVersion;\n                    customUpgradeNeededEvt.newVersion = options.version;\n                    openConnRequest.onupgradeneeded.call({result: evt.target.source}, customUpgradeNeededEvt);\n\n                    database.close();\n                    skladAPI.open(dbName, options).then(resolve, reject);\n                };\n\n                changeVerRequest.onerror = function (evt) {\n                    const err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n                    reject(ensureError(err));\n                };\n\n                return;\n            }\n\n            // store object stores properties in their own map\n            objStoresMeta.set(dbName, new Map());\n\n            resolve(Object.create(skladConnection, {\n                database: {\n                    configurable: true,\n                    enumerable: false,\n                    value: database,\n                    writable: false\n                }\n            }));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onblocked = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n\n            reject(createError('InvalidStateError', `Database ${dbName} is blocked`));\n            isResolvedOrRejected = true;\n        };\n    });\n};\n\n/**\n * Deletes database\n *\n * @param {String} dbName\n * @return {Promise}\n *   @param {Error} [err] if promise is rejected\n */\nskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\n        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n            const err = (evt.type === 'blocked')\n                ? createError('InvalidStateError', `Database ${dbName} is blocked`)\n                : evt.target.error;\n\n            if (err) {\n                reject(ensureError(err));\n            } else {\n                resolve();\n            }\n\n            if (evt.type !== 'success') {\n                evt.preventDefault();\n            }\n        };\n    });\n};\n\nskladAPI.keyValue = function sklad_keyValue(key, value) {\n    return Object.create(skladKeyValueContainer, {\n        key: {value: key, configurable: false, writable: false},\n        value: {value: value, configurable: false, writable: false}\n    });\n};\n\nexport default skladAPI;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/sklad.js\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nclass KinoPromise extends Promise {\n    spread(onFulfilled, onRejected) {\n        function onFulfilledInternal(res) {\n            if (Array.isArray(res)) {\n                return onFulfilled.apply(undefined, _toConsumableArray(res));\n            }\n        };\n\n        return this.then(onFulfilledInternal, onRejected);\n    }\n}\n\nKinoPromise.all = function KinoPromise_static_all(promises) {\n    if (arguments.length > 1 || typeof promises !== 'object') {\n        return Promise.all.apply(Promise, arguments);\n    }\n\n    return new KinoPromise((resolve, reject) => {\n        const isPromisesList = Array.isArray(promises);\n        let promisesArray;\n        let promisesKeys;\n\n        if (isPromisesList) {\n            promisesArray = promises;\n        } else {\n            promisesKeys = Object.keys(promises);\n            promisesArray = promisesKeys.map(key => promises[key]);\n        }\n\n        Promise.all(promisesArray).then(res => {\n            // transform output into an object\n            let output;\n\n            if (isPromisesList) {\n                output = res;\n            } else {\n                output = res.reduce((output, chunk, index) => {\n                    output[promisesKeys[index]] = chunk;\n                    return output;\n                }, {});\n            }\n\n            resolve(output);\n        }).catch(reject);\n    });\n};\n\nexports.default = KinoPromise;\nmodule.exports = exports['default'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/kinopromise/build.js\n **/"],"sourceRoot":""}