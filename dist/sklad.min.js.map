{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sklad.min.js","webpack:///webpack/bootstrap f5d38a56c83b147a3501","webpack:///./lib/sklad.js","webpack:///./~/kinopromise/build.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","uuid","replace","r","Math","random","v","toString","createError","name","message","errObj","Error","ensureError","err","checkSavedData","dbName","objStore","data","keyValueContainer","prototype","isPrototypeOf","skladKeyValueContainer","objStoreMeta","objStoresMeta","get","undefined","keyPath","autoIncrement","_typeof","checkContainingStores","objStoreNames","every","storeName","indexOf","database","objectStoreNames","getObjStoresMeta","db","dbMeta","promises","forEach","objStoreName","has","promise","Promise","resolve","transaction","TRANSACTION_READWRITE","oncomplete","onabort","objectStore","set","Array","isArray","add","ex","abort","push","all","Symbol","iterator","constructor","KinoPromise","window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","mozIDBTransaction","webkitIDBTransaction","msIDBTransaction","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","IDBCursor","mozIDBCursor","webkitIDBCursor","msIDBCursor","TRANSACTION_READONLY","READ_ONLY","READ_WRITE","skladAPI","ASC","NEXT","ASC_UNIQUE","NEXT_NO_DUPLICATE","DESC","PREV","DESC_UNIQUE","PREV_NO_DUPLICATE","supportsObjStoreGetAll","IDBObjectStore","getAll","Map","create","skladConnection","insert","_this","isMulti","arguments","length","keys","allObjStoresExist","version","reject","then","result","abortErr","res","onerror","evt","target","error","isSuccess","type","preventDefault","_loop","_loop2","i","checkedData","req","apply","onsuccess","_ret3","_ret2","upsert","_this2","_loop3","_loop4","put","_ret6","_ret5","delete","_this3","map","_loop5","recordKey","clear","_this4","_this5","_loop6","options","direction","range","useGetAll","iterateRequest","index","indexNames","contains","openCursor","cursorPositionMoved","cursor","offset","advance","limit","_ret9","count","_this6","countRequest","_loop7","rangeArgs","_ret11","close","open","openConnRequest","isResolvedOrRejected","onupgradeneeded","migration","oldVersion","newVersion","parseInt","setVersion","changeVerRequest","customUpgradeNeededEvt","Event","source","errorMessage","webkitErrorMessage","mozErrorMessage","msErrorMessage","onblocked","deleteDatabase","openDbRequest","keyValue","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","_toConsumableArray","arr","arr2","from","_createClass","defineProperties","props","descriptor","protoProps","staticProps","_Promise","getPrototypeOf","onFulfilled","onRejected","onFulfilledInternal","isPromisesList","promisesArray","promisesKeys","output","reduce","chunk"],"mappings":"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","file":"sklad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n\t * https://github.com/1999/sklad\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy\n\t * of this software and associated documentation files (the \"Software\"), to deal\n\t * in the Software without restriction, including without limitation the rights\n\t * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t * copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t * THE SOFTWARE.\n\t *\n\t * @author Dmitry Sorin <info@staypositive.ru>\n\t * @license http://www.opensource.org/licenses/mit-license.html MIT License\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar KinoPromise = __webpack_require__(1);\n\t\n\tif (!window.indexedDB) {\n\t    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\t}\n\t\n\tif (!window.IDBTransaction) {\n\t    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n\t}\n\t\n\tif (!window.IDBKeyRange) {\n\t    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n\t}\n\t\n\tif (!window.IDBCursor) {\n\t    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n\t}\n\t\n\tvar TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\n\tvar TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\t\n\tvar skladAPI = {};\n\tskladAPI.ASC = window.IDBCursor.NEXT || 'next';\n\tskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\n\tskladAPI.DESC = window.IDBCursor.PREV || 'prev';\n\tskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\t\n\t// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n\t// into Array.prototype.indexOf with its code\n\tvar indexOf = Array.prototype.indexOf;\n\tvar supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function';\n\tvar objStoresMeta = new Map();\n\t\n\t/**\n\t * Generates UUIDs for objects without keys set\n\t * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n\t */\n\tfunction uuid() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        var r = Math.random() * 16 | 0;\n\t        var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\n\t        return v.toString(16);\n\t    });\n\t}\n\t\n\tfunction createError(name, message) {\n\t    var errObj = new Error(message);\n\t    errObj.name = name;\n\t\n\t    return errObj;\n\t}\n\t\n\tfunction ensureError(err) {\n\t    if (err instanceof Error) {\n\t        return err;\n\t    }\n\t\n\t    return createError(err.name, err.message);\n\t}\n\t\n\t/**\n\t * Common ancestor for objects created with sklad.keyValue() method\n\t * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n\t */\n\tvar skladKeyValueContainer = Object.create(null);\n\t\n\t/**\n\t * Checks data before saving it in the object store\n\t * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n\t */\n\tfunction checkSavedData(dbName, objStore, data) {\n\t    var keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n\t    var value = keyValueContainer ? data.value : data;\n\t    var objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n\t    var key = keyValueContainer ? data.key : undefined;\n\t\n\t    var keyPath = objStore.keyPath || objStoreMeta.keyPath;\n\t    var autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\t\n\t    if (keyPath === null) {\n\t        if (!autoIncrement && key === undefined) {\n\t            key = uuid();\n\t        }\n\t    } else {\n\t        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n\t            return false;\n\t        }\n\t\n\t        // TODO: support dot-separated and array keyPaths\n\t        if (!autoIncrement && data[keyPath] === undefined) {\n\t            data[keyPath] = uuid();\n\t        }\n\t    }\n\t\n\t    return key ? [value, key] : [value];\n\t}\n\t\n\t/**\n\t * Check whether database contains all needed stores\n\t *\n\t * @param {Array<String>} objStoreNames\n\t * @return {Boolean}\n\t */\n\tfunction checkContainingStores(objStoreNames) {\n\t    return objStoreNames.every(function (storeName) {\n\t        return indexOf.call(this.database.objectStoreNames, storeName) !== -1;\n\t    }, this);\n\t}\n\t\n\t/**\n\t * autoIncrement is broken in IE family. Run this transaction to get its value\n\t * on every object store\n\t *\n\t * @param {IDBDatabase} db\n\t * @param {Array<String>} objStoreNames\n\t * @return {Promise}\n\t *\n\t * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined\n\t * @see https://connect.microsoft.com/IE/Feedback/Details/772726\n\t */\n\tfunction getObjStoresMeta(db, objStoreNames) {\n\t    var dbMeta = objStoresMeta.get(db.name);\n\t    var promises = [];\n\t\n\t    objStoreNames.forEach(function (objStoreName) {\n\t        if (dbMeta.has(objStoreName)) {\n\t            return;\n\t        }\n\t\n\t        var promise = new Promise(function (resolve) {\n\t            var transaction = db.transaction([objStoreName], TRANSACTION_READWRITE);\n\t            transaction.oncomplete = resolve;\n\t            transaction.onabort = resolve;\n\t\n\t            var objStore = transaction.objectStore(objStoreName);\n\t\n\t            if (objStore.autoIncrement !== undefined) {\n\t                dbMeta.set(objStoreName, {\n\t                    autoIncrement: objStore.autoIncrement,\n\t                    keyPath: objStore.keyPath\n\t                });\n\t\n\t                return;\n\t            }\n\t\n\t            var autoIncrement = void 0;\n\t\n\t            if (objStore.keyPath !== null) {\n\t                // if key path is defined it's possible to insert only objects\n\t                // but if key generator (autoIncrement) is not defined the inserted objects\n\t                // must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails\n\t                // so if we run ODBObjectStore.add with an empty object and it fails, this means that\n\t                // autoIncrement property was false. Otherwise - true\n\t                // if key path is array autoIncrement property can't be true\n\t                if (Array.isArray(objStore.keyPath)) {\n\t                    autoIncrement = false;\n\t                } else {\n\t                    try {\n\t                        objStore.add({});\n\t                        autoIncrement = true;\n\t                    } catch (ex) {\n\t                        autoIncrement = false;\n\t                    }\n\t                }\n\t            } else {\n\t                // if key path is not defined it's possible to insert any kind of data\n\t                // but if key generator (autoIncrement) is not defined you should set it explicitly\n\t                // so if we run ODBObjectStore.add with one argument and it fails, this means that\n\t                // autoIncrement property was false. Otherwise - true\n\t                try {\n\t                    objStore.add('some value');\n\t                    autoIncrement = true;\n\t                } catch (ex) {\n\t                    autoIncrement = false;\n\t                }\n\t            }\n\t\n\t            // save meta properties\n\t            dbMeta.set(objStoreName, {\n\t                autoIncrement: autoIncrement,\n\t                keyPath: objStore.keyPath\n\t            });\n\t\n\t            // and abort transaction so that new record is forgotten\n\t            transaction.abort();\n\t        });\n\t\n\t        promises.push(promise);\n\t    });\n\t\n\t    return Promise.all(promises);\n\t}\n\t\n\tvar skladConnection = {\n\t    /**\n\t     * 1) Insert one record into the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {*} inserted object key\n\t     *\n\t     * 2) Insert multiple records into the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} inserted objects' keys\n\t     */\n\t    insert: function skladConnection_insert() {\n\t        var _this = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return getObjStoresMeta(this.database, objStoreNames).then(function () {\n\t            return new Promise(function (resolve, reject) {\n\t                var result = {};\n\t                var transaction = void 0;\n\t                var abortErr = void 0;\n\t\n\t                // Safari9 can't run multi-objectstore transactions\n\t                // divide one transaction into many with one object store to fix this\n\t                try {\n\t                    transaction = _this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t                } catch (ex) {\n\t                    if (ex.name === 'NotFoundError') {\n\t                        (function () {\n\t                            var promises = {};\n\t\n\t                            objStoreNames.forEach(function (objStoreName) {\n\t                                var promise = _this.insert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {\n\t                                    return res[objStoreName];\n\t                                });\n\t\n\t                                promises[objStoreName] = promise;\n\t                            });\n\t\n\t                            KinoPromise.all(promises).then(resolve).catch(reject);\n\t                        })();\n\t                    } else {\n\t                        reject(ex);\n\t                    }\n\t\n\t                    return;\n\t                }\n\t\n\t                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n\t                    var err = abortErr || evt.target.error;\n\t                    var isSuccess = !err && evt.type === 'complete';\n\t\n\t                    if (isSuccess) {\n\t                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                    } else {\n\t                        reject(ensureError(err));\n\t                    }\n\t\n\t                    if (evt.type === 'error') {\n\t                        evt.preventDefault();\n\t                    }\n\t                };\n\t\n\t                var _loop = function _loop(objStoreName) {\n\t                    var objStore = transaction.objectStore(objStoreName);\n\t\n\t                    var _loop2 = function _loop2(i) {\n\t                        var checkedData = checkSavedData(_this.database.name, objStore, data[objStoreName][i]);\n\t\n\t                        if (!checkedData) {\n\t                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t\n\t                        var req = void 0;\n\t                        try {\n\t                            req = objStore.add.apply(objStore, checkedData);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return 'continue';\n\t                        }\n\t\n\t                        req.onsuccess = function (evt) {\n\t                            result[objStoreName] = result[objStoreName] || [];\n\t                            result[objStoreName][i] = evt.target.result;\n\t                        };\n\t                    };\n\t\n\t                    for (var i = 0; i < data[objStoreName].length; i++) {\n\t                        var _ret3 = _loop2(i);\n\t\n\t                        switch (_ret3) {\n\t                            case 'continue':\n\t                                continue;\n\t\n\t                            default:\n\t                                if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n\t                        }\n\t                    }\n\t                };\n\t\n\t                for (var objStoreName in data) {\n\t                    var _ret2 = _loop(objStoreName);\n\t\n\t                    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Insert or update one record in the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {*} inserted/updated object key otherwise\n\t     *\n\t     * 2) Insert or update multiple records in the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} inserted/updated objects' keys otherwise\n\t     */\n\t    upsert: function skladConnection_upsert() {\n\t        var _this2 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return getObjStoresMeta(this.database, objStoreNames).then(function () {\n\t            return new Promise(function (resolve, reject) {\n\t                var result = {};\n\t                var transaction = void 0;\n\t                var abortErr = void 0;\n\t\n\t                // Safari9 can't run multi-objectstore transactions\n\t                // divide one transaction into many with one object store to fix this\n\t                try {\n\t                    transaction = _this2.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t                } catch (ex) {\n\t                    if (ex.name === 'NotFoundError') {\n\t                        (function () {\n\t                            var promises = {};\n\t\n\t                            objStoreNames.forEach(function (objStoreName) {\n\t                                var promise = _this2.upsert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {\n\t                                    return res[objStoreName];\n\t                                });\n\t\n\t                                promises[objStoreName] = promise;\n\t                            });\n\t\n\t                            KinoPromise.all(promises).then(resolve).catch(reject);\n\t                        })();\n\t                    } else {\n\t                        reject(ex);\n\t                    }\n\t\n\t                    return;\n\t                }\n\t\n\t                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n\t                    var err = abortErr || evt.target.error;\n\t                    var isSuccess = !err && evt.type === 'complete';\n\t\n\t                    if (isSuccess) {\n\t                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                    } else {\n\t                        reject(ensureError(err));\n\t                    }\n\t\n\t                    if (evt.type === 'error') {\n\t                        evt.preventDefault();\n\t                    }\n\t                };\n\t\n\t                var _loop3 = function _loop3(objStoreName) {\n\t                    var objStore = transaction.objectStore(objStoreName);\n\t\n\t                    var _loop4 = function _loop4(i) {\n\t                        var checkedData = checkSavedData(_this2.database.name, objStore, data[objStoreName][i]);\n\t\n\t                        if (!checkedData) {\n\t                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t\n\t                        var req = void 0;\n\t                        try {\n\t                            req = objStore.put.apply(objStore, checkedData);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return 'continue';\n\t                        }\n\t\n\t                        req.onsuccess = function (evt) {\n\t                            result[objStoreName] = result[objStoreName] || [];\n\t                            result[objStoreName][i] = evt.target.result;\n\t                        };\n\t                    };\n\t\n\t                    for (var i = 0; i < data[objStoreName].length; i++) {\n\t                        var _ret6 = _loop4(i);\n\t\n\t                        switch (_ret6) {\n\t                            case 'continue':\n\t                                continue;\n\t\n\t                            default:\n\t                                if ((typeof _ret6 === 'undefined' ? 'undefined' : _typeof(_ret6)) === \"object\") return _ret6.v;\n\t                        }\n\t                    }\n\t                };\n\t\n\t                for (var objStoreName in data) {\n\t                    var _ret5 = _loop3(objStoreName);\n\t\n\t                    if ((typeof _ret5 === 'undefined' ? 'undefined' : _typeof(_ret5)) === \"object\") return _ret5.v;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Delete one record from the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Mixed} key\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *\n\t     * 2) Delete multiple records from the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *\n\t     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n\t     */\n\t    delete: function skladConnection_delete() {\n\t        var _this3 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this3.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    var promises = objStoreNames.map(function (objStoreName) {\n\t                        return _this3.delete(objStoreName, data[objStoreName]);\n\t                    });\n\t                    Promise.all(promises).then(function () {\n\t                        return resolve();\n\t                    }).catch(reject);\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject(ensureError(err));\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop5 = function _loop5(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                data[objStoreName].forEach(function (recordKey) {\n\t                    if (abortErr) {\n\t                        return;\n\t                    }\n\t\n\t                    try {\n\t                        objStore.delete(recordKey);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                    }\n\t                });\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                _loop5(objStoreName);\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Clear object store(s)\n\t     *\n\t     * @param {Array|String} objStoreNames array of object stores or a single object store\n\t     * @return {Promise}\n\t     *   @param {Error} err\n\t     */\n\t    clear: function skladConnection_clear(objStoreNames) {\n\t        var _this4 = this;\n\t\n\t        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this4.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    var promises = objStoreNames.map(function (objStoreName) {\n\t                        return _this4.clear([objStoreName]);\n\t                    });\n\t                    Promise.all(promises).then(function () {\n\t                        return resolve();\n\t                    }).catch(reject);\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject(ensureError(err));\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            objStoreNames.forEach(function (objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                if (abortErr) {\n\t                    return;\n\t                }\n\t\n\t                try {\n\t                    objStore.clear();\n\t                } catch (ex) {\n\t                    abortErr = ex;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Get objects from one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Array} stored objects otherwise\n\t     *\n\t     * 2) Get objects from multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} stored objects otherwise\n\t     */\n\t    get: function skladConnection_get() {\n\t        var _this5 = this;\n\t\n\t        var isMulti = arguments.length === 2 && _typeof(arguments[0]) === 'object' && typeof arguments[1] === 'function';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var result = {};\n\t        var data = void 0,\n\t            abortErr = void 0;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        objStoreNames.forEach(function (objStoreName) {\n\t            result[objStoreName] = [];\n\t        });\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this5.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    (function () {\n\t                        var promises = {};\n\t\n\t                        objStoreNames.forEach(function (objStoreName) {\n\t                            var promise = _this5.get(objStoreName, data[objStoreName]);\n\t                            promises[objStoreName] = promise;\n\t                        });\n\t\n\t                        KinoPromise.all(promises).then(resolve).catch(reject);\n\t                    })();\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject(ensureError(err));\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop6 = function _loop6(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var direction = options.direction || skladAPI.ASC;\n\t                var range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\t\n\t                var useGetAll = false;\n\t                var iterateRequest = void 0;\n\t\n\t                if (supportsObjStoreGetAll) {\n\t                    useGetAll = Object.keys(options).every(function (key) {\n\t                        return key === 'limit' || key === 'range';\n\t                    });\n\t                }\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = createError('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                } /* else if (useGetAll) {\n\t                     // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n\t                     try {\n\t                         objStore.getAll(range, options.limit || Number.POSITIVE_INFINITY).onsuccess = function (evt) {\n\t                             const result = evt.target.result;\n\t                             console.log(JSON.stringify(result, null, '    '));\n\t                              // result[objStoreName].push({\n\t                             //     key: cursor.key,\n\t                             //     value: cursor.value\n\t                             // });\n\t                         };\n\t                     } catch (ex) {\n\t                         abortErr = ex;\n\t                         return;\n\t                     }\n\t                  }*/else {\n\t                        try {\n\t                            iterateRequest = objStore.openCursor(range, direction);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return {\n\t                                v: void 0\n\t                            };\n\t                        }\n\t                    }\n\t\n\t                var cursorPositionMoved = false;\n\t\n\t                iterateRequest.onsuccess = function (evt) {\n\t                    var cursor = evt.target.result;\n\t\n\t                    // no more results\n\t                    if (!cursor) {\n\t                        return;\n\t                    }\n\t\n\t                    if (options.offset && !cursorPositionMoved) {\n\t                        cursorPositionMoved = true;\n\t                        cursor.advance(options.offset);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    result[objStoreName].push({\n\t                        key: cursor.key,\n\t                        value: cursor.value\n\t                    });\n\t\n\t                    if (options.limit && options.limit === result[objStoreName].length) {\n\t                        return;\n\t                    }\n\t\n\t                    cursor.continue();\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret9 = _loop6(objStoreName);\n\t\n\t                if ((typeof _ret9 === 'undefined' ? 'undefined' : _typeof(_ret9)) === \"object\") return _ret9.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Count objects in one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Number} number of stored objects otherwise\n\t     *\n\t     * 2) Count objects in multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} number of stored objects otherwise\n\t     */\n\t    count: function skladConnection_count() {\n\t        var _this6 = this;\n\t\n\t        var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t        var data = void 0;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = createError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var result = {};\n\t            var transaction = void 0;\n\t            var countRequest = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this6.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    (function () {\n\t                        var promises = {};\n\t\n\t                        objStoreNames.forEach(function (objStoreName) {\n\t                            var promise = _this6.count(objStoreName, data[objStoreName]);\n\t                            promises[objStoreName] = promise;\n\t                        });\n\t\n\t                        KinoPromise.all(promises).then(resolve).catch(reject);\n\t                    })();\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject(ensureError(err));\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop7 = function _loop7(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var rangeArgs = options.range instanceof window.IDBKeyRange ? [options.range] : [];\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = createError('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        var index = objStore.index(options.index);\n\t                        countRequest = index.count.apply(index, rangeArgs);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                } else {\n\t                    try {\n\t                        countRequest = objStore.count.apply(objStore, rangeArgs);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                }\n\t\n\t                countRequest.onsuccess = function (evt) {\n\t                    result[objStoreName] = evt.target.result || 0;\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret11 = _loop7(objStoreName);\n\t\n\t                if ((typeof _ret11 === 'undefined' ? 'undefined' : _typeof(_ret11)) === \"object\") return _ret11.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Close IndexedDB connection\n\t     */\n\t    close: function skladConnection_close() {\n\t        this.database.close();\n\t        delete this.database;\n\t    }\n\t};\n\t\n\t/**\n\t * Opens connection to a database\n\t *\n\t * @param {String} dbName database name\n\t * @param {Object} [options = {}] connection options\n\t * @param {Number} [options.version] database version\n\t * @param {Object} [options.migration] migration scripts\n\t * @return {Promise}\n\t *   @param {Object} [conn] if - promise is resolved\n\t *   @param {Error} [err] - if promise is rejected\n\t */\n\tskladAPI.open = function sklad_open(dbName) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? { version: 1 } : arguments[1];\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openConnRequest = window.indexedDB.open(dbName, options.version);\n\t        var isResolvedOrRejected = false;\n\t\n\t        openConnRequest.onupgradeneeded = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            options.migration = options.migration || {};\n\t            for (var i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n\t                if (!options.migration[i]) continue;\n\t\n\t                options.migration[i].call(this, this.result);\n\t            }\n\t        };\n\t\n\t        openConnRequest.onerror = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t            reject(ensureError(evt.target.error));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onsuccess = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            var database = this.result;\n\t            var oldVersion = parseInt(database.version || 0, 10);\n\t\n\t            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n\t                var changeVerRequest = database.setVersion(options.version);\n\t\n\t                changeVerRequest.onsuccess = function (evt) {\n\t                    var customUpgradeNeededEvt = new Event('upgradeneeded');\n\t                    customUpgradeNeededEvt.oldVersion = oldVersion;\n\t                    customUpgradeNeededEvt.newVersion = options.version;\n\t                    openConnRequest.onupgradeneeded.call({ result: evt.target.source }, customUpgradeNeededEvt);\n\t\n\t                    database.close();\n\t                    skladAPI.open(dbName, options).then(resolve, reject);\n\t                };\n\t\n\t                changeVerRequest.onerror = function (evt) {\n\t                    var err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n\t                    reject(ensureError(err));\n\t                };\n\t\n\t                return;\n\t            }\n\t\n\t            // store object stores properties in their own map\n\t            objStoresMeta.set(dbName, new Map());\n\t\n\t            resolve(Object.create(skladConnection, {\n\t                database: {\n\t                    configurable: true,\n\t                    enumerable: false,\n\t                    value: database,\n\t                    writable: false\n\t                }\n\t            }));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onblocked = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t\n\t            reject(createError('InvalidStateError', 'Database ' + dbName + ' is blocked'));\n\t            isResolvedOrRejected = true;\n\t        };\n\t    });\n\t};\n\t\n\t/**\n\t * Deletes database\n\t *\n\t * @param {String} dbName\n\t * @return {Promise}\n\t *   @param {Error} [err] if promise is rejected\n\t */\n\tskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\t\n\t        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n\t            var err = evt.type === 'blocked' ? createError('InvalidStateError', 'Database ' + dbName + ' is blocked') : evt.target.error;\n\t\n\t            if (err) {\n\t                reject(ensureError(err));\n\t            } else {\n\t                resolve();\n\t            }\n\t\n\t            if (evt.type !== 'success') {\n\t                evt.preventDefault();\n\t            }\n\t        };\n\t    });\n\t};\n\t\n\tskladAPI.keyValue = function sklad_keyValue(key, value) {\n\t    return Object.create(skladKeyValueContainer, {\n\t        key: { value: key, configurable: false, writable: false },\n\t        value: { value: value, configurable: false, writable: false }\n\t    });\n\t};\n\t\n\texports.default = skladAPI;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _toConsumableArray(arr) {\n\t    if (Array.isArray(arr)) {\n\t        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t            arr2[i] = arr[i];\n\t        }return arr2;\n\t    } else {\n\t        return Array.from(arr);\n\t    }\n\t}\n\t\n\tvar KinoPromise = function (_Promise) {\n\t    _inherits(KinoPromise, _Promise);\n\t\n\t    function KinoPromise() {\n\t        _classCallCheck(this, KinoPromise);\n\t\n\t        return _possibleConstructorReturn(this, Object.getPrototypeOf(KinoPromise).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(KinoPromise, [{\n\t        key: 'spread',\n\t        value: function spread(onFulfilled, onRejected) {\n\t            function onFulfilledInternal(res) {\n\t                if (Array.isArray(res)) {\n\t                    return onFulfilled.apply(undefined, _toConsumableArray(res));\n\t                }\n\t            };\n\t\n\t            return this.then(onFulfilledInternal, onRejected);\n\t        }\n\t    }]);\n\t\n\t    return KinoPromise;\n\t}(Promise);\n\t\n\tKinoPromise.all = function KinoPromise_static_all(promises) {\n\t    if (arguments.length > 1 || (typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) !== 'object') {\n\t        return Promise.all.apply(Promise, arguments);\n\t    }\n\t\n\t    return new KinoPromise(function (resolve, reject) {\n\t        var isPromisesList = Array.isArray(promises);\n\t        var promisesArray = void 0;\n\t        var promisesKeys = void 0;\n\t\n\t        if (isPromisesList) {\n\t            promisesArray = promises;\n\t        } else {\n\t            promisesKeys = Object.keys(promises);\n\t            promisesArray = promisesKeys.map(function (key) {\n\t                return promises[key];\n\t            });\n\t        }\n\t\n\t        Promise.all(promisesArray).then(function (res) {\n\t            // transform output into an object\n\t            var output = void 0;\n\t\n\t            if (isPromisesList) {\n\t                output = res;\n\t            } else {\n\t                output = res.reduce(function (output, chunk, index) {\n\t                    output[promisesKeys[index]] = chunk;\n\t                    return output;\n\t                }, {});\n\t            }\n\t\n\t            resolve(output);\n\t        }).catch(reject);\n\t    });\n\t};\n\t\n\texports.default = KinoPromise;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** sklad.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f5d38a56c83b147a3501\n **/","/**\n * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n * https://github.com/1999/sklad\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author Dmitry Sorin <info@staypositive.ru>\n * @license http://www.opensource.org/licenses/mit-license.html MIT License\n */\n'use strict';\n\nconst KinoPromise = require('kinopromise');\n\nif (!window.indexedDB) {\n    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n}\n\nif (!window.IDBTransaction) {\n    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n}\n\nif (!window.IDBKeyRange) {\n    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n}\n\nif (!window.IDBCursor) {\n    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n}\n\nconst TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\nconst TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\nconst skladAPI = {};\nskladAPI.ASC = window.IDBCursor.NEXT || 'next';\nskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\nskladAPI.DESC = window.IDBCursor.PREV || 'prev';\nskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\n// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n// into Array.prototype.indexOf with its code\nconst indexOf = Array.prototype.indexOf;\nconst supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function';\nconst objStoresMeta = new Map();\n\n/**\n * Generates UUIDs for objects without keys set\n * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n */\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = (c === 'x') ? r : (r&0x3|0x8);\n\n        return v.toString(16);\n    });\n}\n\nfunction createError(name, message) {\n    const errObj = new Error(message);\n    errObj.name = name;\n\n    return errObj;\n}\n\nfunction ensureError(err) {\n    if (err instanceof Error) {\n        return err;\n    }\n\n    return createError(err.name, err.message);\n}\n\n/**\n * Common ancestor for objects created with sklad.keyValue() method\n * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n */\nconst skladKeyValueContainer = Object.create(null);\n\n/**\n * Checks data before saving it in the object store\n * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n */\nfunction checkSavedData(dbName, objStore, data) {\n    const keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n    const value = keyValueContainer ? data.value : data;\n    const objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n    let key = keyValueContainer ? data.key : undefined;\n\n    const keyPath = objStore.keyPath || objStoreMeta.keyPath;\n    const autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\n    if (keyPath === null) {\n        if (!autoIncrement && key === undefined) {\n            key = uuid();\n        }\n    } else {\n        if (typeof data !== 'object') {\n            return false;\n        }\n\n        // TODO: support dot-separated and array keyPaths\n        if (!autoIncrement && data[keyPath] === undefined) {\n            data[keyPath] = uuid();\n        }\n    }\n\n    return key ? [value, key] : [value];\n}\n\n/**\n * Check whether database contains all needed stores\n *\n * @param {Array<String>} objStoreNames\n * @return {Boolean}\n */\nfunction checkContainingStores(objStoreNames) {\n    return objStoreNames.every(function (storeName) {\n        return (indexOf.call(this.database.objectStoreNames, storeName) !== -1);\n    }, this);\n}\n\n/**\n * autoIncrement is broken in IE family. Run this transaction to get its value\n * on every object store\n *\n * @param {IDBDatabase} db\n * @param {Array<String>} objStoreNames\n * @return {Promise}\n *\n * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined\n * @see https://connect.microsoft.com/IE/Feedback/Details/772726\n */\nfunction getObjStoresMeta(db, objStoreNames) {\n    const dbMeta = objStoresMeta.get(db.name);\n    const promises = [];\n\n    objStoreNames.forEach(objStoreName => {\n        if (dbMeta.has(objStoreName)) {\n            return;\n        }\n\n        const promise = new Promise(resolve => {\n            const transaction = db.transaction([objStoreName], TRANSACTION_READWRITE);\n            transaction.oncomplete = resolve;\n            transaction.onabort = resolve;\n\n            const objStore = transaction.objectStore(objStoreName);\n\n            if (objStore.autoIncrement !== undefined) {\n                dbMeta.set(objStoreName, {\n                    autoIncrement: objStore.autoIncrement,\n                    keyPath: objStore.keyPath\n                });\n\n                return;\n            }\n\n            let autoIncrement;\n\n            if (objStore.keyPath !== null) {\n                // if key path is defined it's possible to insert only objects\n                // but if key generator (autoIncrement) is not defined the inserted objects\n                // must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails\n                // so if we run ODBObjectStore.add with an empty object and it fails, this means that\n                // autoIncrement property was false. Otherwise - true\n                // if key path is array autoIncrement property can't be true\n                if (Array.isArray(objStore.keyPath)) {\n                    autoIncrement = false;\n                } else {\n                    try {\n                        objStore.add({});\n                        autoIncrement = true;\n                    } catch (ex) {\n                        autoIncrement = false;\n                    }\n                }\n            } else {\n                // if key path is not defined it's possible to insert any kind of data\n                // but if key generator (autoIncrement) is not defined you should set it explicitly\n                // so if we run ODBObjectStore.add with one argument and it fails, this means that\n                // autoIncrement property was false. Otherwise - true\n                try {\n                    objStore.add('some value');\n                    autoIncrement = true;\n                } catch (ex) {\n                    autoIncrement = false;\n                }\n            }\n\n            // save meta properties\n            dbMeta.set(objStoreName, {\n                autoIncrement: autoIncrement,\n                keyPath: objStore.keyPath\n            });\n\n            // and abort transaction so that new record is forgotten\n            transaction.abort();\n        });\n\n        promises.push(promise);\n    });\n\n    return Promise.all(promises);\n}\n\nconst skladConnection = {\n    /**\n     * 1) Insert one record into the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {*} inserted object key\n     *\n     * 2) Insert multiple records into the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} inserted objects' keys\n     */\n    insert: function skladConnection_insert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return getObjStoresMeta(this.database, objStoreNames).then(() => {\n            return new Promise((resolve, reject) => {\n                const result = {};\n                let transaction;\n                let abortErr;\n\n                // Safari9 can't run multi-objectstore transactions\n                // divide one transaction into many with one object store to fix this\n                try {\n                    transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n                } catch (ex) {\n                    if (ex.name === 'NotFoundError') {\n                        const promises = {};\n\n                        objStoreNames.forEach(objStoreName => {\n                            const promise = this.insert({\n                                [objStoreName]: Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]]\n                            }).then(res => res[objStoreName]);\n\n                            promises[objStoreName] = promise;\n                        });\n\n                        KinoPromise.all(promises).then(resolve).catch(reject);\n                    } else {\n                        reject(ex);\n                    }\n\n                    return;\n                }\n\n                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n                    const err = abortErr || evt.target.error;\n                    const isSuccess = !err && evt.type === 'complete';\n\n                    if (isSuccess) {\n                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                    } else {\n                        reject(ensureError(err));\n                    }\n\n                    if (evt.type === 'error') {\n                        evt.preventDefault();\n                    }\n                };\n\n                for (let objStoreName in data) {\n                    const objStore = transaction.objectStore(objStoreName);\n\n                    for (let i = 0; i < data[objStoreName].length; i++) {\n                        const checkedData = checkSavedData(this.database.name, objStore, data[objStoreName][i]);\n\n                        if (!checkedData) {\n                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                            return;\n                        }\n\n                        let req;\n                        try {\n                            req = objStore.add.apply(objStore, checkedData);\n                        } catch (ex) {\n                            abortErr = ex;\n                            continue;\n                        }\n\n                        req.onsuccess = function (evt) {\n                            result[objStoreName] = result[objStoreName] || [];\n                            result[objStoreName][i] = evt.target.result;\n                        };\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Insert or update one record in the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {*} inserted/updated object key otherwise\n     *\n     * 2) Insert or update multiple records in the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} inserted/updated objects' keys otherwise\n     */\n    upsert: function skladConnection_upsert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return getObjStoresMeta(this.database, objStoreNames).then(() => {\n            return new Promise((resolve, reject) => {\n                const result = {};\n                let transaction;\n                let abortErr;\n\n                // Safari9 can't run multi-objectstore transactions\n                // divide one transaction into many with one object store to fix this\n                try {\n                    transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n                } catch (ex) {\n                    if (ex.name === 'NotFoundError') {\n                        const promises = {};\n\n                        objStoreNames.forEach(objStoreName => {\n                            const promise = this.upsert({\n                                [objStoreName]: Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]]\n                            }).then(res => res[objStoreName]);\n\n                            promises[objStoreName] = promise;\n                        });\n\n                        KinoPromise.all(promises).then(resolve).catch(reject);\n                    } else {\n                        reject(ex);\n                    }\n\n                    return;\n                }\n\n                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n                    const err = abortErr || evt.target.error;\n                    const isSuccess = !err && evt.type === 'complete';\n\n                    if (isSuccess) {\n                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                    } else {\n                        reject(ensureError(err));\n                    }\n\n                    if (evt.type === 'error') {\n                        evt.preventDefault();\n                    }\n                };\n\n                for (let objStoreName in data) {\n                    const objStore = transaction.objectStore(objStoreName);\n\n                    for (let i = 0; i < data[objStoreName].length; i++) {\n                        const checkedData = checkSavedData(this.database.name, objStore, data[objStoreName][i]);\n\n                        if (!checkedData) {\n                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                            return;\n                        }\n\n                        let req;\n                        try {\n                            req = objStore.put.apply(objStore, checkedData);\n                        } catch (ex) {\n                            abortErr = ex;\n                            continue;\n                        }\n\n                        req.onsuccess = function (evt) {\n                            result[objStoreName] = result[objStoreName] || [];\n                            result[objStoreName][i] = evt.target.result;\n                        };\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Delete one record from the object store\n     * @param {String} objStoreName name of object store\n     * @param {Mixed} key\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *\n     * 2) Delete multiple records from the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *\n     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n     */\n    delete: function skladConnection_delete() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = objStoreNames.map(objStoreName => this.delete(objStoreName, data[objStoreName]));\n                    Promise.all(promises).then(() => resolve()).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(ensureError(err));\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n\n                data[objStoreName].forEach(recordKey => {\n                    if (abortErr) {\n                        return;\n                    }\n\n                    try {\n                        objStore.delete(recordKey);\n                    } catch (ex) {\n                        abortErr = ex;\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Clear object store(s)\n     *\n     * @param {Array|String} objStoreNames array of object stores or a single object store\n     * @return {Promise}\n     *   @param {Error} err\n     */\n    clear: function skladConnection_clear(objStoreNames) {\n        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = objStoreNames.map(objStoreName => this.clear([objStoreName]));\n                    Promise.all(promises).then(() => resolve()).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(ensureError(err));\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            objStoreNames.forEach(objStoreName => {\n                const objStore = transaction.objectStore(objStoreName);\n\n                if (abortErr) {\n                    return;\n                }\n\n                try {\n                    objStore.clear();\n                } catch (ex) {\n                    abortErr = ex;\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Get objects from one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Array} stored objects otherwise\n     *\n     * 2) Get objects from multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} stored objects otherwise\n     */\n    get: function skladConnection_get() {\n        const isMulti = (arguments.length === 2 && typeof arguments[0] === 'object' && typeof arguments[1] === 'function');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let result = {};\n        let data, abortErr;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        objStoreNames.forEach(function (objStoreName) {\n            result[objStoreName] = [];\n        });\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = {};\n\n                    objStoreNames.forEach(objStoreName => {\n                        const promise = this.get(objStoreName, data[objStoreName]);\n                        promises[objStoreName] = promise;\n                    });\n\n                    KinoPromise.all(promises).then(resolve).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]]);\n                } else {\n                    reject(ensureError(err));\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const direction = options.direction || skladAPI.ASC;\n                const range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\n                let useGetAll = false;\n                let iterateRequest;\n\n                if (supportsObjStoreGetAll) {\n                    useGetAll = Object.keys(options).every(function (key) {\n                        return key === 'limit' || key === 'range';\n                    });\n                }\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }/* else if (useGetAll) {\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    try {\n                        objStore.getAll(range, options.limit || Number.POSITIVE_INFINITY).onsuccess = function (evt) {\n                            const result = evt.target.result;\n                            console.log(JSON.stringify(result, null, '    '));\n\n                            // result[objStoreName].push({\n                            //     key: cursor.key,\n                            //     value: cursor.value\n                            // });\n                        };\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }*/ else {\n                    try {\n                        iterateRequest = objStore.openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                let cursorPositionMoved = false;\n\n                iterateRequest.onsuccess = function (evt) {\n                    const cursor = evt.target.result;\n\n                    // no more results\n                    if (!cursor) {\n                        return;\n                    }\n\n                    if (options.offset && !cursorPositionMoved) {\n                        cursorPositionMoved = true;\n                        cursor.advance(options.offset);\n\n                        return;\n                    }\n\n                    result[objStoreName].push({\n                        key: cursor.key,\n                        value: cursor.value\n                    });\n\n                    if (options.limit && options.limit === result[objStoreName].length) {\n                        return;\n                    }\n\n                    cursor.continue();\n                };\n            }\n        });\n    },\n\n    /**\n     * 1) Count objects in one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Number} number of stored objects otherwise\n     *\n     * 2) Count objects in multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} number of stored objects otherwise\n     */\n    count: function skladConnection_count() {\n        const isMulti = (arguments.length === 1 && typeof arguments[0] === 'object');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n        let data;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            const result = {};\n            let transaction;\n            let countRequest;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = {};\n\n                    objStoreNames.forEach(objStoreName => {\n                        const promise = this.count(objStoreName, data[objStoreName]);\n                        promises[objStoreName] = promise;\n                    });\n\n                    KinoPromise.all(promises).then(resolve).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]])\n                } else {\n                    reject(ensureError(err));\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const rangeArgs = (options.range instanceof window.IDBKeyRange) ? [options.range] : [];\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        const index = objStore.index(options.index);\n                        countRequest = index.count(...rangeArgs);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else {\n                    try {\n                        countRequest = objStore.count(...rangeArgs);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                countRequest.onsuccess = function (evt) {\n                    result[objStoreName] = evt.target.result || 0;\n                };\n            }\n        });\n    },\n\n    /**\n     * Close IndexedDB connection\n     */\n    close: function skladConnection_close() {\n        this.database.close();\n        delete this.database;\n    }\n};\n\n/**\n * Opens connection to a database\n *\n * @param {String} dbName database name\n * @param {Object} [options = {}] connection options\n * @param {Number} [options.version] database version\n * @param {Object} [options.migration] migration scripts\n * @return {Promise}\n *   @param {Object} [conn] if - promise is resolved\n *   @param {Error} [err] - if promise is rejected\n */\nskladAPI.open = function sklad_open(dbName, options = {version: 1}) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openConnRequest = window.indexedDB.open(dbName, options.version);\n        let isResolvedOrRejected = false;\n\n        openConnRequest.onupgradeneeded = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            options.migration = options.migration || {};\n            for (let i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n                if (!options.migration[i])\n                    continue;\n\n                options.migration[i].call(this, this.result);\n            }\n        };\n\n        openConnRequest.onerror = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n            reject(ensureError(evt.target.error));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onsuccess = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            const database = this.result;\n            const oldVersion = parseInt(database.version || 0, 10);\n\n            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n                const changeVerRequest = database.setVersion(options.version);\n\n                changeVerRequest.onsuccess = function (evt) {\n                    const customUpgradeNeededEvt = new Event('upgradeneeded');\n                    customUpgradeNeededEvt.oldVersion = oldVersion;\n                    customUpgradeNeededEvt.newVersion = options.version;\n                    openConnRequest.onupgradeneeded.call({result: evt.target.source}, customUpgradeNeededEvt);\n\n                    database.close();\n                    skladAPI.open(dbName, options).then(resolve, reject);\n                };\n\n                changeVerRequest.onerror = function (evt) {\n                    const err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n                    reject(ensureError(err));\n                };\n\n                return;\n            }\n\n            // store object stores properties in their own map\n            objStoresMeta.set(dbName, new Map());\n\n            resolve(Object.create(skladConnection, {\n                database: {\n                    configurable: true,\n                    enumerable: false,\n                    value: database,\n                    writable: false\n                }\n            }));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onblocked = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n\n            reject(createError('InvalidStateError', `Database ${dbName} is blocked`));\n            isResolvedOrRejected = true;\n        };\n    });\n};\n\n/**\n * Deletes database\n *\n * @param {String} dbName\n * @return {Promise}\n *   @param {Error} [err] if promise is rejected\n */\nskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\n        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n            const err = (evt.type === 'blocked')\n                ? createError('InvalidStateError', `Database ${dbName} is blocked`)\n                : evt.target.error;\n\n            if (err) {\n                reject(ensureError(err));\n            } else {\n                resolve();\n            }\n\n            if (evt.type !== 'success') {\n                evt.preventDefault();\n            }\n        };\n    });\n};\n\nskladAPI.keyValue = function sklad_keyValue(key, value) {\n    return Object.create(skladKeyValueContainer, {\n        key: {value: key, configurable: false, writable: false},\n        value: {value: value, configurable: false, writable: false}\n    });\n};\n\nexport default skladAPI;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/sklad.js\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nclass KinoPromise extends Promise {\n    spread(onFulfilled, onRejected) {\n        function onFulfilledInternal(res) {\n            if (Array.isArray(res)) {\n                return onFulfilled.apply(undefined, _toConsumableArray(res));\n            }\n        };\n\n        return this.then(onFulfilledInternal, onRejected);\n    }\n}\n\nKinoPromise.all = function KinoPromise_static_all(promises) {\n    if (arguments.length > 1 || typeof promises !== 'object') {\n        return Promise.all.apply(Promise, arguments);\n    }\n\n    return new KinoPromise((resolve, reject) => {\n        const isPromisesList = Array.isArray(promises);\n        let promisesArray;\n        let promisesKeys;\n\n        if (isPromisesList) {\n            promisesArray = promises;\n        } else {\n            promisesKeys = Object.keys(promises);\n            promisesArray = promisesKeys.map(key => promises[key]);\n        }\n\n        Promise.all(promisesArray).then(res => {\n            // transform output into an object\n            let output;\n\n            if (isPromisesList) {\n                output = res;\n            } else {\n                output = res.reduce((output, chunk, index) => {\n                    output[promisesKeys[index]] = chunk;\n                    return output;\n                }, {});\n            }\n\n            resolve(output);\n        }).catch(reject);\n    });\n};\n\nexports.default = KinoPromise;\nmodule.exports = exports['default'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/kinopromise/build.js\n **/"],"sourceRoot":""}