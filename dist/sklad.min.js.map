{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sklad.min.js","webpack:///webpack/bootstrap 21651f727dbf8dc00b07","webpack:///./lib/sklad.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","uuid","replace","r","Math","random","v","toString","checkSavedData","objStore","data","keyValueContainer","Object","prototype","isPrototypeOf","skladKeyValueContainer","value","key","undefined","keyPath","autoIncrement","_typeof","checkContainingStores","objStoreNames","every","storeName","indexOf","database","objectStoreNames","defineProperty","Symbol","iterator","obj","constructor","window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","mozIDBTransaction","webkitIDBTransaction","msIDBTransaction","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","IDBCursor","mozIDBCursor","webkitIDBCursor","msIDBCursor","TRANSACTION_READONLY","READ_ONLY","TRANSACTION_READWRITE","READ_WRITE","skladAPI","ASC","NEXT","ASC_UNIQUE","NEXT_NO_DUPLICATE","DESC","PREV","DESC_UNIQUE","PREV_NO_DUPLICATE","Array","supportsObjStoreGetAll","IDBObjectStore","getAll","create","skladConnection","insert","_this","isMulti","arguments","length","keys","allObjStoresExist","err","DOMError","name","version","Promise","reject","resolve","result","transaction","abortErr","oncomplete","onerror","onabort","evt","target","error","isSuccess","type","preventDefault","_loop","objStoreName","objectStore","_loop2","i","checkedData","req","add","apply","ex","onsuccess","_ret2","_ret","upsert","_this2","_loop3","_loop4","put","_ret4","_ret3","delete","_this3","_loop5","forEach","clear","_this4","isArray","get","_this5","_loop6","options","direction","range","useGetAll","iterateRequest","index","indexNames","contains","openCursor","limit","Number","POSITIVE_INFINITY","console","log","JSON","stringify","cursorPositionMoved","cursor","offset","advance","push","_ret6","count","_this6","countRequest","_loop7","_ret7","close","open","dbName","openConnRequest","isResolvedOrRejected","onupgradeneeded","migration","oldVersion","newVersion","parseInt","setVersion","changeVerRequest","customUpgradeNeededEvt","Event","source","then","errorMessage","webkitErrorMessage","mozErrorMessage","msErrorMessage","configurable","enumerable","writable","onblocked","deleteDatabase","openDbRequest","keyValue"],"mappings":"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","file":"sklad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n\t * https://github.com/1999/sklad\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy\n\t * of this software and associated documentation files (the \"Software\"), to deal\n\t * in the Software without restriction, including without limitation the rights\n\t * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t * copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t * THE SOFTWARE.\n\t *\n\t * @author Dmitry Sorin <info@staypositive.ru>\n\t * @license http://www.opensource.org/licenses/mit-license.html MIT License\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tif (!window.indexedDB) {\n\t    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\t}\n\t\n\tif (!window.IDBTransaction) {\n\t    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n\t}\n\t\n\tif (!window.IDBKeyRange) {\n\t    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n\t}\n\t\n\tif (!window.IDBCursor) {\n\t    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n\t}\n\t\n\tvar TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\n\tvar TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\t\n\tvar skladAPI = {};\n\tskladAPI.ASC = window.IDBCursor.NEXT || 'next';\n\tskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\n\tskladAPI.DESC = window.IDBCursor.PREV || 'prev';\n\tskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\t\n\t// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n\t// into Array.prototype.indexOf with its code\n\tvar indexOf = Array.prototype.indexOf;\n\tvar supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function';\n\t\n\t/**\n\t * Generates UUIDs for objects without keys set\n\t * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n\t */\n\tfunction uuid() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        var r = Math.random() * 16 | 0;\n\t        var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\n\t        return v.toString(16);\n\t    });\n\t}\n\t\n\t/**\n\t * Common ancestor for objects created with sklad.keyValue() method\n\t * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n\t */\n\tvar skladKeyValueContainer = Object.create(null);\n\t\n\t/**\n\t * Checks data before saving it in the object store\n\t * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n\t */\n\tfunction checkSavedData(objStore, data) {\n\t    var keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n\t    var value = keyValueContainer ? data.value : data;\n\t    var key = keyValueContainer ? data.key : undefined;\n\t\n\t    if (objStore.keyPath === null) {\n\t        if (!objStore.autoIncrement && key === undefined) {\n\t            key = uuid();\n\t        }\n\t    } else {\n\t        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n\t            return false;\n\t        }\n\t\n\t        if (!objStore.autoIncrement && data[objStore.keyPath] === undefined) {\n\t            data[objStore.keyPath] = uuid();\n\t        }\n\t    }\n\t\n\t    return key ? [value, key] : [value];\n\t}\n\t\n\t/**\n\t * Check whether database contains all needed stores\n\t *\n\t * @param {Array} objStoreNames\n\t * @return {Boolean}\n\t */\n\tfunction checkContainingStores(objStoreNames) {\n\t    return objStoreNames.every(function (storeName) {\n\t        return indexOf.call(this.database.objectStoreNames, storeName) !== -1;\n\t    }, this);\n\t}\n\t\n\tvar skladConnection = {\n\t    /**\n\t     * 1) Insert one record into the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {*} inserted object key\n\t     *\n\t     * 2) Insert multiple records into the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {Object} inserted objects' keys\n\t     */\n\t    insert: function skladConnection_insert() {\n\t        var _this = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = new DOMError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = undefined;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var result = {};\n\t            var transaction = _this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            var abortErr = undefined;\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                } else {\n\t                    reject(err);\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop = function _loop(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                var _loop2 = function _loop2(i) {\n\t                    var checkedData = checkSavedData(objStore, data[objStoreName][i]);\n\t\n\t                    if (!checkedData) {\n\t                        abortErr = new DOMError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                        return {\n\t                            v: {\n\t                                v: undefined\n\t                            }\n\t                        };\n\t                    }\n\t\n\t                    var req = undefined;\n\t                    try {\n\t                        req = objStore.add.apply(objStore, checkedData);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return 'continue';\n\t                    }\n\t\n\t                    req.onsuccess = function (evt) {\n\t                        result[objStoreName] = result[objStoreName] || [];\n\t                        result[objStoreName][i] = evt.target.result;\n\t                    };\n\t                };\n\t\n\t                for (var i = 0; i < data[objStoreName].length; i++) {\n\t                    var _ret2 = _loop2(i);\n\t\n\t                    switch (_ret2) {\n\t                        case 'continue':\n\t                            continue;\n\t\n\t                        default:\n\t                            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t                    }\n\t                }\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret = _loop(objStoreName);\n\t\n\t                if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Insert or update one record in the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {*} inserted/updated object key otherwise\n\t     *\n\t     * 2) Insert or update multiple records in the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {Object} inserted/updated objects' keys otherwise\n\t     */\n\t    upsert: function skladConnection_upsert() {\n\t        var _this2 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = new DOMError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = undefined;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var result = {};\n\t            var transaction = _this2.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            var abortErr = undefined;\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                } else {\n\t                    reject(err);\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop3 = function _loop3(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                var _loop4 = function _loop4(i) {\n\t                    var checkedData = checkSavedData(objStore, data[objStoreName][i]);\n\t\n\t                    if (!checkedData) {\n\t                        abortErr = new DOMError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                        return {\n\t                            v: {\n\t                                v: undefined\n\t                            }\n\t                        };\n\t                    }\n\t\n\t                    var req = undefined;\n\t                    try {\n\t                        req = objStore.put.apply(objStore, checkedData);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return 'continue';\n\t                    }\n\t\n\t                    req.onsuccess = function (evt) {\n\t                        result[objStoreName] = result[objStoreName] || [];\n\t                        result[objStoreName][i] = evt.target.result;\n\t                    };\n\t                };\n\t\n\t                for (var i = 0; i < data[objStoreName].length; i++) {\n\t                    var _ret4 = _loop4(i);\n\t\n\t                    switch (_ret4) {\n\t                        case 'continue':\n\t                            continue;\n\t\n\t                        default:\n\t                            if ((typeof _ret4 === 'undefined' ? 'undefined' : _typeof(_ret4)) === \"object\") return _ret4.v;\n\t                    }\n\t                }\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret3 = _loop3(objStoreName);\n\t\n\t                if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Delete one record from the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Mixed} key\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *\n\t     * 2) Delete multiple records from the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *\n\t     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n\t     */\n\t    delete: function skladConnection_delete() {\n\t        var _this3 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = new DOMError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = undefined;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = _this3.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            var abortErr = undefined;\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject(err);\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop5 = function _loop5(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                data[objStoreName].forEach(function (objStoreName) {\n\t                    if (abortErr) {\n\t                        return;\n\t                    }\n\t\n\t                    try {\n\t                        objStore.delete(objStoreName);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                    }\n\t                });\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                _loop5(objStoreName);\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Clear object store(s)\n\t     *\n\t     * @param {Array|String} objStoreNames array of object stores or a single object store\n\t     * @return {Promise}\n\t     *   @param {DOMError} err\n\t     */\n\t    clear: function skladConnection_clear(objStoreNames) {\n\t        var _this4 = this;\n\t\n\t        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = new DOMError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = _this4.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            var abortErr = undefined;\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject(err);\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            objStoreNames.forEach(function (objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                if (abortErr) {\n\t                    return;\n\t                }\n\t\n\t                try {\n\t                    objStore.clear();\n\t                } catch (ex) {\n\t                    abortErr = ex;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Get objects from one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {Array} stored objects otherwise\n\t     *\n\t     * 2) Get objects from multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {Object} stored objects otherwise\n\t     */\n\t    get: function skladConnection_get() {\n\t        var _this5 = this;\n\t\n\t        var isMulti = arguments.length === 2 && _typeof(arguments[0]) === 'object' && typeof arguments[1] === 'function';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = new DOMError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var result = {};\n\t        var data = undefined,\n\t            abortErr = undefined;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        objStoreNames.forEach(function (objStoreName) {\n\t            result[objStoreName] = [];\n\t        });\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = _this5.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject(err);\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop6 = function _loop6(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var direction = options.direction || skladAPI.ASC;\n\t                var range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\t\n\t                var useGetAll = false;\n\t                var iterateRequest = undefined;\n\t\n\t                if (supportsObjStoreGetAll) {\n\t                    useGetAll = Object.keys(options).every(function (key) {\n\t                        return key === 'limit' || key === 'range';\n\t                    });\n\t                }\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = new DOMError('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t                } else if (useGetAll) {\n\t                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n\t                    try {\n\t                        objStore.getAll(range, options.limit || Number.POSITIVE_INFINITY).onsuccess = function (evt) {\n\t                            var result = evt.target.result;\n\t                            console.log(JSON.stringify(result, null, '    '));\n\t\n\t                            // result[objStoreName].push({\n\t                            //     key: cursor.key,\n\t                            //     value: cursor.value\n\t                            // });\n\t                        };\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t                } else {\n\t                    try {\n\t                        iterateRequest = objStore.openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t                }\n\t\n\t                var cursorPositionMoved = false;\n\t\n\t                iterateRequest.onsuccess = function (evt) {\n\t                    var cursor = evt.target.result;\n\t\n\t                    // no more results\n\t                    if (!cursor) {\n\t                        return;\n\t                    }\n\t\n\t                    if (options.offset && !cursorPositionMoved) {\n\t                        cursorPositionMoved = true;\n\t                        cursor.advance(options.offset);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    result[objStoreName].push({\n\t                        key: cursor.key,\n\t                        value: cursor.value\n\t                    });\n\t\n\t                    if (options.limit && options.limit === result[objStoreName].length) {\n\t                        return;\n\t                    }\n\t\n\t                    cursor.continue();\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret6 = _loop6(objStoreName);\n\t\n\t                if ((typeof _ret6 === 'undefined' ? 'undefined' : _typeof(_ret6)) === \"object\") return _ret6.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Count objects in one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {Number} number of stored objects otherwise\n\t     *\n\t     * 2) Count objects in multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {DOMError} [err] if promise is rejected\n\t     *   @param {Object} number of stored objects otherwise\n\t     */\n\t    count: function skladConnection_count() {\n\t        var _this6 = this;\n\t\n\t        var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t        var data = undefined;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = new DOMError('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var result = {};\n\t            var transaction = _this6.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            var countRequest = undefined,\n\t                abortErr = undefined;\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject(err);\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop7 = function _loop7(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = new DOMError('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        countRequest = objStore.index(options.index).count(range);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t                } else {\n\t                    try {\n\t                        countRequest = objStore.count(range);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: undefined\n\t                        };\n\t                    }\n\t                }\n\t\n\t                countRequest.onsuccess = function (evt) {\n\t                    result[objStoreName] = evt.target.result || 0;\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret7 = _loop7(objStoreName);\n\t\n\t                if ((typeof _ret7 === 'undefined' ? 'undefined' : _typeof(_ret7)) === \"object\") return _ret7.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Close IndexedDB connection\n\t     */\n\t    close: function skladConnection_close() {\n\t        this.database.close();\n\t        delete this.database;\n\t    }\n\t};\n\t\n\t/**\n\t * Opens connection to a database\n\t *\n\t * @param {String} dbName database name\n\t * @param {Object} [options = {}] connection options\n\t * @param {Number} [options.version] database version\n\t * @param {Object} [options.migration] migration scripts\n\t * @return {Promise}\n\t *   @param {Object} [conn] if - promise is resolved\n\t *   @param {DOMError} [err] - if promise is rejected\n\t */\n\tskladAPI.open = function sklad_open(dbName) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? { version: 1 } : arguments[1];\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject(new DOMError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openConnRequest = window.indexedDB.open(dbName, options.version);\n\t        var isResolvedOrRejected = false;\n\t\n\t        openConnRequest.onupgradeneeded = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            options.migration = options.migration || {};\n\t            for (var i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n\t                if (!options.migration[i]) continue;\n\t\n\t                options.migration[i].call(this, this.result);\n\t            }\n\t        };\n\t\n\t        openConnRequest.onerror = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t            reject(evt.target.error);\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onsuccess = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            var database = this.result;\n\t            var oldVersion = parseInt(database.version || 0, 10);\n\t\n\t            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n\t                var changeVerRequest = database.setVersion(options.version);\n\t\n\t                changeVerRequest.onsuccess = function (evt) {\n\t                    var customUpgradeNeededEvt = new Event('upgradeneeded');\n\t                    customUpgradeNeededEvt.oldVersion = oldVersion;\n\t                    customUpgradeNeededEvt.newVersion = options.version;\n\t                    openConnRequest.onupgradeneeded.call({ result: evt.target.source }, customUpgradeNeededEvt);\n\t\n\t                    database.close();\n\t                    skladAPI.open(dbName, options).then(resolve, reject);\n\t                };\n\t\n\t                changeVerRequest.onerror = function (evt) {\n\t                    var err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n\t                    reject(err);\n\t                };\n\t\n\t                return;\n\t            }\n\t\n\t            resolve(Object.create(skladConnection, {\n\t                database: {\n\t                    configurable: true,\n\t                    enumerable: false,\n\t                    value: database,\n\t                    writable: false\n\t                }\n\t            }));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onblocked = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t\n\t            reject(new DOMError('InvalidStateError', 'Database ' + dbName + ' is blocked'));\n\t            isResolvedOrRejected = true;\n\t        };\n\t    });\n\t};\n\t\n\t/**\n\t * Deletes database\n\t *\n\t * @param {String} dbName\n\t * @return {Promise}\n\t *   @param {DOMError} [err] if promise is rejected\n\t */\n\tskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject(new DOMError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\t\n\t        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n\t            var err = evt.type === 'blocked' ? new DOMError('InvalidStateError', 'Database ' + dbName + ' is blocked') : evt.target.error;\n\t\n\t            if (err) {\n\t                reject(err);\n\t            } else {\n\t                resolve();\n\t            }\n\t\n\t            if (evt.type !== 'success') {\n\t                evt.preventDefault();\n\t            }\n\t        };\n\t    });\n\t};\n\t\n\tskladAPI.keyValue = function sklad_keyValue(key, value) {\n\t    return Object.create(skladKeyValueContainer, {\n\t        key: { value: key, configurable: false, writable: false },\n\t        value: { value: value, configurable: false, writable: false }\n\t    });\n\t};\n\t\n\texports.default = skladAPI;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** sklad.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 21651f727dbf8dc00b07\n **/","/**\n * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n * https://github.com/1999/sklad\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author Dmitry Sorin <info@staypositive.ru>\n * @license http://www.opensource.org/licenses/mit-license.html MIT License\n */\n'use strict';\n\nif (!window.indexedDB) {\n    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n}\n\nif (!window.IDBTransaction) {\n    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n}\n\nif (!window.IDBKeyRange) {\n    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n}\n\nif (!window.IDBCursor) {\n    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n}\n\nconst TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\nconst TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\nconst skladAPI = {};\nskladAPI.ASC = window.IDBCursor.NEXT || 'next';\nskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\nskladAPI.DESC = window.IDBCursor.PREV || 'prev';\nskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\n// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n// into Array.prototype.indexOf with its code\nconst indexOf = Array.prototype.indexOf;\nconst supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function';\n\n/**\n * Generates UUIDs for objects without keys set\n * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n */\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = (c === 'x') ? r : (r&0x3|0x8);\n\n        return v.toString(16);\n    });\n}\n\n/**\n * Common ancestor for objects created with sklad.keyValue() method\n * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n */\nconst skladKeyValueContainer = Object.create(null);\n\n/**\n * Checks data before saving it in the object store\n * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n */\nfunction checkSavedData(objStore, data) {\n    const keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n    const value = keyValueContainer ? data.value : data;\n    let key = keyValueContainer ? data.key : undefined;\n\n    if (objStore.keyPath === null) {\n        if (!objStore.autoIncrement && key === undefined) {\n            key = uuid();\n        }\n    } else {\n        if (typeof data !== 'object') {\n            return false;\n        }\n\n        if (!objStore.autoIncrement && data[objStore.keyPath] === undefined) {\n            data[objStore.keyPath] = uuid();\n        }\n    }\n\n    return key ? [value, key] : [value];\n}\n\n/**\n * Check whether database contains all needed stores\n *\n * @param {Array} objStoreNames\n * @return {Boolean}\n */\nfunction checkContainingStores(objStoreNames) {\n    return objStoreNames.every(function (storeName) {\n        return (indexOf.call(this.database.objectStoreNames, storeName) !== -1);\n    }, this);\n}\n\nconst skladConnection = {\n    /**\n     * 1) Insert one record into the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {*} inserted object key\n     *\n     * 2) Insert multiple records into the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {Object} inserted objects' keys\n     */\n    insert: function skladConnection_insert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = new DOMError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return new Promise((resolve, reject) => {\n            const result = {};\n            const transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            let abortErr;\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                } else {\n                    reject(err);\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n\n                for (let i = 0; i < data[objStoreName].length; i++) {\n                    const checkedData = checkSavedData(objStore, data[objStoreName][i]);\n\n                    if (!checkedData) {\n                        abortErr = new DOMError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                        return;\n                    }\n\n                    let req;\n                    try {\n                        req = objStore.add.apply(objStore, checkedData);\n                    } catch (ex) {\n                        abortErr = ex;\n                        continue;\n                    }\n\n                    req.onsuccess = function (evt) {\n                        result[objStoreName] = result[objStoreName] || [];\n                        result[objStoreName][i] = evt.target.result;\n                    };\n                }\n            }\n        });\n    },\n\n    /**\n     * 1) Insert or update one record in the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {*} inserted/updated object key otherwise\n     *\n     * 2) Insert or update multiple records in the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {Object} inserted/updated objects' keys otherwise\n     */\n    upsert: function skladConnection_upsert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = new DOMError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return new Promise((resolve, reject) => {\n            const result = {};\n            const transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            let abortErr;\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                } else {\n                    reject(err);\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n\n                for (let i = 0; i < data[objStoreName].length; i++) {\n                    const checkedData = checkSavedData(objStore, data[objStoreName][i]);\n\n                    if (!checkedData) {\n                        abortErr = new DOMError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                        return;\n                    }\n\n                    let req;\n                    try {\n                        req = objStore.put.apply(objStore, checkedData);\n                    } catch (ex) {\n                        abortErr = ex;\n                        continue;\n                    }\n\n                    req.onsuccess = function (evt) {\n                        result[objStoreName] = result[objStoreName] || [];\n                        result[objStoreName][i] = evt.target.result;\n                    };\n                }\n            }\n        });\n    },\n\n    /**\n     * 1) Delete one record from the object store\n     * @param {String} objStoreName name of object store\n     * @param {Mixed} key\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *\n     * 2) Delete multiple records from the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *\n     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n     */\n    delete: function skladConnection_delete() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = new DOMError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            let abortErr;\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n\n                data[objStoreName].forEach(objStoreName => {\n                    if (abortErr) {\n                        return;\n                    }\n\n                    try {\n                        objStore.delete(objStoreName);\n                    } catch (ex) {\n                        abortErr = ex;\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Clear object store(s)\n     *\n     * @param {Array|String} objStoreNames array of object stores or a single object store\n     * @return {Promise}\n     *   @param {DOMError} err\n     */\n    clear: function skladConnection_clear(objStoreNames) {\n        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = new DOMError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            let abortErr;\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            objStoreNames.forEach(objStoreName => {\n                const objStore = transaction.objectStore(objStoreName);\n\n                if (abortErr) {\n                    return;\n                }\n\n                try {\n                    objStore.clear();\n                } catch (ex) {\n                    abortErr = ex;\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Get objects from one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {Array} stored objects otherwise\n     *\n     * 2) Get objects from multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {Object} stored objects otherwise\n     */\n    get: function skladConnection_get() {\n        const isMulti = (arguments.length === 2 && typeof arguments[0] === 'object' && typeof arguments[1] === 'function');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = new DOMError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let result = {};\n        let data, abortErr;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        objStoreNames.forEach(function (objStoreName) {\n            result[objStoreName] = [];\n        });\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]]);\n                } else {\n                    reject(err);\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const direction = options.direction || skladAPI.ASC;\n                const range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\n                let useGetAll = false;\n                let iterateRequest;\n\n                if (supportsObjStoreGetAll) {\n                    useGetAll = Object.keys(options).every(function (key) {\n                        return key === 'limit' || key === 'range';\n                    });\n                }\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = new DOMError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else if (useGetAll) {\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    try {\n                        objStore.getAll(range, options.limit || Number.POSITIVE_INFINITY).onsuccess = function (evt) {\n                            const result = evt.target.result;\n                            console.log(JSON.stringify(result, null, '    '));\n\n                            // result[objStoreName].push({\n                            //     key: cursor.key,\n                            //     value: cursor.value\n                            // });\n                        };\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else {\n                    try {\n                        iterateRequest = objStore.openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                let cursorPositionMoved = false;\n\n                iterateRequest.onsuccess = function (evt) {\n                    const cursor = evt.target.result;\n\n                    // no more results\n                    if (!cursor) {\n                        return;\n                    }\n\n                    if (options.offset && !cursorPositionMoved) {\n                        cursorPositionMoved = true;\n                        cursor.advance(options.offset);\n\n                        return;\n                    }\n\n                    result[objStoreName].push({\n                        key: cursor.key,\n                        value: cursor.value\n                    });\n\n                    if (options.limit && options.limit === result[objStoreName].length) {\n                        return;\n                    }\n\n                    cursor.continue();\n                };\n            }\n        });\n    },\n\n    /**\n     * 1) Count objects in one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {Number} number of stored objects otherwise\n     *\n     * 2) Count objects in multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {DOMError} [err] if promise is rejected\n     *   @param {Object} number of stored objects otherwise\n     */\n    count: function skladConnection_count() {\n        const isMulti = (arguments.length === 1 && typeof arguments[0] === 'object');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n        let data;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = new DOMError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            const result = {};\n            const transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            let countRequest, abortErr;\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]])\n                } else {\n                    reject(err);\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const range = (options.range instanceof window.IDBKeyRange) ? options.range : null;\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = new DOMError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        countRequest = objStore.index(options.index).count(range);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else {\n                    try {\n                        countRequest = objStore.count(range);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                countRequest.onsuccess = function (evt) {\n                    result[objStoreName] = evt.target.result || 0;\n                };\n            }\n        });\n    },\n\n    /**\n     * Close IndexedDB connection\n     */\n    close: function skladConnection_close() {\n        this.database.close();\n        delete this.database;\n    }\n};\n\n/**\n * Opens connection to a database\n *\n * @param {String} dbName database name\n * @param {Object} [options = {}] connection options\n * @param {Number} [options.version] database version\n * @param {Object} [options.migration] migration scripts\n * @return {Promise}\n *   @param {Object} [conn] if - promise is resolved\n *   @param {DOMError} [err] - if promise is rejected\n */\nskladAPI.open = function sklad_open(dbName, options = {version: 1}) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(new DOMError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openConnRequest = window.indexedDB.open(dbName, options.version);\n        let isResolvedOrRejected = false;\n\n        openConnRequest.onupgradeneeded = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            options.migration = options.migration || {};\n            for (let i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n                if (!options.migration[i])\n                    continue;\n\n                options.migration[i].call(this, this.result);\n            }\n        };\n\n        openConnRequest.onerror = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n            reject(evt.target.error);\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onsuccess = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            const database = this.result;\n            const oldVersion = parseInt(database.version || 0, 10);\n\n            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n                const changeVerRequest = database.setVersion(options.version);\n\n                changeVerRequest.onsuccess = function (evt) {\n                    const customUpgradeNeededEvt = new Event('upgradeneeded');\n                    customUpgradeNeededEvt.oldVersion = oldVersion;\n                    customUpgradeNeededEvt.newVersion = options.version;\n                    openConnRequest.onupgradeneeded.call({result: evt.target.source}, customUpgradeNeededEvt);\n\n                    database.close();\n                    skladAPI.open(dbName, options).then(resolve, reject);\n                };\n\n                changeVerRequest.onerror = function (evt) {\n                    const err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n                    reject(err);\n                };\n\n                return;\n            }\n\n            resolve(Object.create(skladConnection, {\n                database: {\n                    configurable: true,\n                    enumerable: false,\n                    value: database,\n                    writable: false\n                }\n            }));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onblocked = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n\n            reject(new DOMError('InvalidStateError', `Database ${dbName} is blocked`));\n            isResolvedOrRejected = true;\n        };\n    });\n};\n\n/**\n * Deletes database\n *\n * @param {String} dbName\n * @return {Promise}\n *   @param {DOMError} [err] if promise is rejected\n */\nskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(new DOMError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\n        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n            const err = (evt.type === 'blocked')\n                ? new DOMError('InvalidStateError', `Database ${dbName} is blocked`)\n                : evt.target.error;\n\n            if (err) {\n                reject(err);\n            } else {\n                resolve();\n            }\n\n            if (evt.type !== 'success') {\n                evt.preventDefault();\n            }\n        };\n    });\n};\n\nskladAPI.keyValue = function sklad_keyValue(key, value) {\n    return Object.create(skladKeyValueContainer, {\n        key: {value: key, configurable: false, writable: false},\n        value: {value: value, configurable: false, writable: false}\n    });\n};\n\nexport default skladAPI;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/sklad.js\n **/"],"sourceRoot":""}