{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sklad.min.js","webpack:///webpack/bootstrap d1da6d9ab6a11d1b2d06","webpack:///./lib/sklad.js","webpack:///./~/kinopromise/build.js","webpack:///./lib/uuid.js","webpack:///./lib/error.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","checkSavedData","dbName","objStore","data","keyValueContainer","prototype","isPrototypeOf","skladKeyValueContainer","objStoreMeta","objStoresMeta","get","name","undefined","keyPath","autoIncrement","_uuid2","_typeof","checkContainingStores","objStoreNames","every","storeName","indexOf","database","objectStoreNames","getObjStoresMeta","db","dbMeta","promises","forEach","objStoreName","has","promise","Promise","resolve","transaction","TRANSACTION_READWRITE","oncomplete","onabort","objectStore","set","Array","isArray","add","ex","abort","push","all","Symbol","iterator","constructor","_kinopromise","_kinopromise2","_uuid","_error","window","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","mozIDBTransaction","webkitIDBTransaction","msIDBTransaction","IDBKeyRange","mozIDBKeyRange","webkitIDBKeyRange","msIDBKeyRange","IDBCursor","mozIDBCursor","webkitIDBCursor","msIDBCursor","TRANSACTION_READONLY","READ_ONLY","READ_WRITE","skladAPI","ASC","NEXT","ASC_UNIQUE","NEXT_NO_DUPLICATE","DESC","PREV","DESC_UNIQUE","PREV_NO_DUPLICATE","supportsObjStoreGetAll","IDBObjectStore","getAll","getAllKeys","Map","create","skladConnection","insert","_this","isMulti","arguments","length","keys","allObjStoresExist","err","createError","version","reject","then","result","abortErr","res","onerror","evt","target","error","isSuccess","type","ensureError","preventDefault","_loop","_loop2","i","checkedData","v","req","apply","onsuccess","_ret3","_ret2","upsert","_this2","_loop3","_loop4","put","_ret6","_ret5","delete","_this3","map","_loop5","recordKey","clear","_this4","_this5","_loop6","options","direction","range","useGetAll","iterateRequest","index","indexNames","contains","openCursor","_ret10","args","offset","limit","values","resultIndex","cursorPositionMoved","cursor","advance","_ret9","count","_this6","countRequest","_loop7","rangeArgs","_ret12","close","open","openConnRequest","isResolvedOrRejected","onupgradeneeded","migration","oldVersion","newVersion","parseInt","setVersion","changeVerRequest","customUpgradeNeededEvt","Event","source","errorMessage","webkitErrorMessage","mozErrorMessage","msErrorMessage","onblocked","deleteDatabase","openDbRequest","keyValue","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","setPrototypeOf","__proto__","_toConsumableArray","arr","arr2","from","_createClass","defineProperties","props","descriptor","protoProps","staticProps","KinoPromise","_Promise","getPrototypeOf","onFulfilled","onRejected","onFulfilledInternal","isPromisesList","promisesArray","promisesKeys","output","reduce","chunk","uuid","replace","r","Math","random","toString","message","errObj","Error"],"mappings":"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","file":"sklad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sklad\"] = factory();\n\telse\n\t\troot[\"sklad\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n\t * https://github.com/1999/sklad\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy\n\t * of this software and associated documentation files (the \"Software\"), to deal\n\t * in the Software without restriction, including without limitation the rights\n\t * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t * copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\t * THE SOFTWARE.\n\t *\n\t * @author Dmitry Sorin <info@staypositive.ru>\n\t * @license http://www.opensource.org/licenses/mit-license.html MIT License\n\t */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _kinopromise = __webpack_require__(1);\n\t\n\tvar _kinopromise2 = _interopRequireDefault(_kinopromise);\n\t\n\tvar _uuid = __webpack_require__(2);\n\t\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\t\n\tvar _error = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tif (!window.indexedDB) {\n\t    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\t}\n\t\n\tif (!window.IDBTransaction) {\n\t    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n\t}\n\t\n\tif (!window.IDBKeyRange) {\n\t    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n\t}\n\t\n\tif (!window.IDBCursor) {\n\t    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n\t}\n\t\n\tvar TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\n\tvar TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\t\n\tvar skladAPI = {};\n\tskladAPI.ASC = window.IDBCursor.NEXT || 'next';\n\tskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\n\tskladAPI.DESC = window.IDBCursor.PREV || 'prev';\n\tskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\t\n\t// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n\t// into Array.prototype.indexOf with its code\n\tvar indexOf = Array.prototype.indexOf;\n\tvar supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function' && typeof IDBObjectStore.prototype.getAllKeys === 'function';\n\tvar objStoresMeta = new Map();\n\t\n\t/**\n\t * Common ancestor for objects created with sklad.keyValue() method\n\t * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n\t */\n\tvar skladKeyValueContainer = Object.create(null);\n\t\n\t/**\n\t * Checks data before saving it in the object store\n\t * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n\t */\n\tfunction checkSavedData(dbName, objStore, data) {\n\t    var keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n\t    var value = keyValueContainer ? data.value : data;\n\t    var objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n\t    var key = keyValueContainer ? data.key : undefined;\n\t\n\t    var keyPath = objStore.keyPath || objStoreMeta.keyPath;\n\t    var autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\t\n\t    if (keyPath === null) {\n\t        if (!autoIncrement && key === undefined) {\n\t            key = (0, _uuid2.default)();\n\t        }\n\t    } else {\n\t        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n\t            return false;\n\t        }\n\t\n\t        // TODO: support dot-separated and array keyPaths\n\t        if (!autoIncrement && data[keyPath] === undefined) {\n\t            data[keyPath] = (0, _uuid2.default)();\n\t        }\n\t    }\n\t\n\t    return key ? [value, key] : [value];\n\t}\n\t\n\t/**\n\t * Check whether database contains all needed stores\n\t *\n\t * @param {Array<String>} objStoreNames\n\t * @return {Boolean}\n\t */\n\tfunction checkContainingStores(objStoreNames) {\n\t    return objStoreNames.every(function (storeName) {\n\t        return indexOf.call(this.database.objectStoreNames, storeName) !== -1;\n\t    }, this);\n\t}\n\t\n\t/**\n\t * autoIncrement is broken in IE family. Run this transaction to get its value\n\t * on every object store\n\t *\n\t * @param {IDBDatabase} db\n\t * @param {Array<String>} objStoreNames\n\t * @return {Promise}\n\t *\n\t * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined\n\t * @see https://connect.microsoft.com/IE/Feedback/Details/772726\n\t */\n\tfunction getObjStoresMeta(db, objStoreNames) {\n\t    var dbMeta = objStoresMeta.get(db.name);\n\t    var promises = [];\n\t\n\t    objStoreNames.forEach(function (objStoreName) {\n\t        if (dbMeta.has(objStoreName)) {\n\t            return;\n\t        }\n\t\n\t        var promise = new Promise(function (resolve) {\n\t            var transaction = db.transaction([objStoreName], TRANSACTION_READWRITE);\n\t            transaction.oncomplete = resolve;\n\t            transaction.onabort = resolve;\n\t\n\t            var objStore = transaction.objectStore(objStoreName);\n\t\n\t            if (objStore.autoIncrement !== undefined) {\n\t                dbMeta.set(objStoreName, {\n\t                    autoIncrement: objStore.autoIncrement,\n\t                    keyPath: objStore.keyPath\n\t                });\n\t\n\t                return;\n\t            }\n\t\n\t            var autoIncrement = void 0;\n\t\n\t            if (objStore.keyPath !== null) {\n\t                // if key path is defined it's possible to insert only objects\n\t                // but if key generator (autoIncrement) is not defined the inserted objects\n\t                // must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails\n\t                // so if we run ODBObjectStore.add with an empty object and it fails, this means that\n\t                // autoIncrement property was false. Otherwise - true\n\t                // if key path is array autoIncrement property can't be true\n\t                if (Array.isArray(objStore.keyPath)) {\n\t                    autoIncrement = false;\n\t                } else {\n\t                    try {\n\t                        objStore.add({});\n\t                        autoIncrement = true;\n\t                    } catch (ex) {\n\t                        autoIncrement = false;\n\t                    }\n\t                }\n\t            } else {\n\t                // if key path is not defined it's possible to insert any kind of data\n\t                // but if key generator (autoIncrement) is not defined you should set it explicitly\n\t                // so if we run ODBObjectStore.add with one argument and it fails, this means that\n\t                // autoIncrement property was false. Otherwise - true\n\t                try {\n\t                    objStore.add('some value');\n\t                    autoIncrement = true;\n\t                } catch (ex) {\n\t                    autoIncrement = false;\n\t                }\n\t            }\n\t\n\t            // save meta properties\n\t            dbMeta.set(objStoreName, {\n\t                autoIncrement: autoIncrement,\n\t                keyPath: objStore.keyPath\n\t            });\n\t\n\t            // and abort transaction so that new record is forgotten\n\t            transaction.abort();\n\t        });\n\t\n\t        promises.push(promise);\n\t    });\n\t\n\t    return Promise.all(promises);\n\t}\n\t\n\tvar skladConnection = {\n\t    /**\n\t     * 1) Insert one record into the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {*} inserted object key\n\t     *\n\t     * 2) Insert multiple records into the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} inserted objects' keys\n\t     */\n\t    insert: function skladConnection_insert() {\n\t        var _this = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return getObjStoresMeta(this.database, objStoreNames).then(function () {\n\t            return new Promise(function (resolve, reject) {\n\t                var result = {};\n\t                var transaction = void 0;\n\t                var abortErr = void 0;\n\t\n\t                // Safari9 can't run multi-objectstore transactions\n\t                // divide one transaction into many with one object store to fix this\n\t                try {\n\t                    transaction = _this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t                } catch (ex) {\n\t                    if (ex.name === 'NotFoundError') {\n\t                        (function () {\n\t                            var promises = {};\n\t\n\t                            objStoreNames.forEach(function (objStoreName) {\n\t                                var promise = _this.insert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {\n\t                                    return res[objStoreName];\n\t                                });\n\t\n\t                                promises[objStoreName] = promise;\n\t                            });\n\t\n\t                            _kinopromise2.default.all(promises).then(resolve).catch(reject);\n\t                        })();\n\t                    } else {\n\t                        reject(ex);\n\t                    }\n\t\n\t                    return;\n\t                }\n\t\n\t                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n\t                    var err = abortErr || evt.target.error;\n\t                    var isSuccess = !err && evt.type === 'complete';\n\t\n\t                    if (isSuccess) {\n\t                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                    } else {\n\t                        reject((0, _error.ensureError)(err));\n\t                    }\n\t\n\t                    if (evt.type === 'error') {\n\t                        evt.preventDefault();\n\t                    }\n\t                };\n\t\n\t                var _loop = function _loop(objStoreName) {\n\t                    var objStore = transaction.objectStore(objStoreName);\n\t\n\t                    var _loop2 = function _loop2(i) {\n\t                        var checkedData = checkSavedData(_this.database.name, objStore, data[objStoreName][i]);\n\t\n\t                        if (!checkedData) {\n\t                            abortErr = (0, _error.createError)('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t\n\t                        var req = void 0;\n\t                        try {\n\t                            req = objStore.add.apply(objStore, checkedData);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return 'continue';\n\t                        }\n\t\n\t                        req.onsuccess = function (evt) {\n\t                            result[objStoreName] = result[objStoreName] || [];\n\t                            result[objStoreName][i] = evt.target.result;\n\t                        };\n\t                    };\n\t\n\t                    for (var i = 0; i < data[objStoreName].length; i++) {\n\t                        var _ret3 = _loop2(i);\n\t\n\t                        switch (_ret3) {\n\t                            case 'continue':\n\t                                continue;\n\t\n\t                            default:\n\t                                if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n\t                        }\n\t                    }\n\t                };\n\t\n\t                for (var objStoreName in data) {\n\t                    var _ret2 = _loop(objStoreName);\n\t\n\t                    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Insert or update one record in the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {*} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {*} inserted/updated object key otherwise\n\t     *\n\t     * 2) Insert or update multiple records in the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} inserted/updated objects' keys otherwise\n\t     */\n\t    upsert: function skladConnection_upsert() {\n\t        var _this2 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return getObjStoresMeta(this.database, objStoreNames).then(function () {\n\t            return new Promise(function (resolve, reject) {\n\t                var result = {};\n\t                var transaction = void 0;\n\t                var abortErr = void 0;\n\t\n\t                // Safari9 can't run multi-objectstore transactions\n\t                // divide one transaction into many with one object store to fix this\n\t                try {\n\t                    transaction = _this2.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t                } catch (ex) {\n\t                    if (ex.name === 'NotFoundError') {\n\t                        (function () {\n\t                            var promises = {};\n\t\n\t                            objStoreNames.forEach(function (objStoreName) {\n\t                                var promise = _this2.upsert(_defineProperty({}, objStoreName, Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]])).then(function (res) {\n\t                                    return res[objStoreName];\n\t                                });\n\t\n\t                                promises[objStoreName] = promise;\n\t                            });\n\t\n\t                            _kinopromise2.default.all(promises).then(resolve).catch(reject);\n\t                        })();\n\t                    } else {\n\t                        reject(ex);\n\t                    }\n\t\n\t                    return;\n\t                }\n\t\n\t                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n\t                    var err = abortErr || evt.target.error;\n\t                    var isSuccess = !err && evt.type === 'complete';\n\t\n\t                    if (isSuccess) {\n\t                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n\t                    } else {\n\t                        reject((0, _error.ensureError)(err));\n\t                    }\n\t\n\t                    if (evt.type === 'error') {\n\t                        evt.preventDefault();\n\t                    }\n\t                };\n\t\n\t                var _loop3 = function _loop3(objStoreName) {\n\t                    var objStore = transaction.objectStore(objStoreName);\n\t\n\t                    var _loop4 = function _loop4(i) {\n\t                        var checkedData = checkSavedData(_this2.database.name, objStore, data[objStoreName][i]);\n\t\n\t                        if (!checkedData) {\n\t                            abortErr = (0, _error.createError)('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n\t                            return {\n\t                                v: {\n\t                                    v: void 0\n\t                                }\n\t                            };\n\t                        }\n\t\n\t                        var req = void 0;\n\t                        try {\n\t                            req = objStore.put.apply(objStore, checkedData);\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                            return 'continue';\n\t                        }\n\t\n\t                        req.onsuccess = function (evt) {\n\t                            result[objStoreName] = result[objStoreName] || [];\n\t                            result[objStoreName][i] = evt.target.result;\n\t                        };\n\t                    };\n\t\n\t                    for (var i = 0; i < data[objStoreName].length; i++) {\n\t                        var _ret6 = _loop4(i);\n\t\n\t                        switch (_ret6) {\n\t                            case 'continue':\n\t                                continue;\n\t\n\t                            default:\n\t                                if ((typeof _ret6 === 'undefined' ? 'undefined' : _typeof(_ret6)) === \"object\") return _ret6.v;\n\t                        }\n\t                    }\n\t                };\n\t\n\t                for (var objStoreName in data) {\n\t                    var _ret5 = _loop3(objStoreName);\n\t\n\t                    if ((typeof _ret5 === 'undefined' ? 'undefined' : _typeof(_ret5)) === \"object\") return _ret5.v;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Delete one record from the object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Mixed} key\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *\n\t     * 2) Delete multiple records from the object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *\n\t     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n\t     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n\t     */\n\t    delete: function skladConnection_delete() {\n\t        var _this3 = this;\n\t\n\t        var isMulti = arguments.length === 1;\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var data = void 0;\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = [arguments[1]];\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this3.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    var promises = objStoreNames.map(function (objStoreName) {\n\t                        return _this3.delete(objStoreName, data[objStoreName]);\n\t                    });\n\t                    Promise.all(promises).then(function () {\n\t                        return resolve();\n\t                    }).catch(reject);\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject((0, _error.ensureError)(err));\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop5 = function _loop5(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                data[objStoreName].forEach(function (recordKey) {\n\t                    if (abortErr) {\n\t                        return;\n\t                    }\n\t\n\t                    try {\n\t                        objStore.delete(recordKey);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                    }\n\t                });\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                _loop5(objStoreName);\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Clear object store(s)\n\t     *\n\t     * @param {Array|String} objStoreNames array of object stores or a single object store\n\t     * @return {Promise}\n\t     *   @param {Error} err\n\t     */\n\t    clear: function skladConnection_clear(objStoreNames) {\n\t        var _this4 = this;\n\t\n\t        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this4.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    var promises = objStoreNames.map(function (objStoreName) {\n\t                        return _this4.clear([objStoreName]);\n\t                    });\n\t                    Promise.all(promises).then(function () {\n\t                        return resolve();\n\t                    }).catch(reject);\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t\n\t                if (err) {\n\t                    reject((0, _error.ensureError)(err));\n\t                } else {\n\t                    resolve();\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            objStoreNames.forEach(function (objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t\n\t                if (abortErr) {\n\t                    return;\n\t                }\n\t\n\t                try {\n\t                    objStore.clear();\n\t                } catch (ex) {\n\t                    abortErr = ex;\n\t                }\n\t            });\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Get objects from one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Array} stored objects otherwise\n\t     *\n\t     * 2) Get objects from multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} stored objects otherwise\n\t     */\n\t    get: function skladConnection_get() {\n\t        var _this5 = this;\n\t\n\t        var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        var result = {};\n\t        var data = void 0,\n\t            abortErr = void 0;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = arguments[1];\n\t        }\n\t\n\t        objStoreNames.forEach(function (objStoreName) {\n\t            result[objStoreName] = [];\n\t        });\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var transaction = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this5.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    (function () {\n\t                        var promises = {};\n\t\n\t                        objStoreNames.forEach(function (objStoreName) {\n\t                            var promise = _this5.get(objStoreName, data[objStoreName]);\n\t                            promises[objStoreName] = promise;\n\t                        });\n\t\n\t                        _kinopromise2.default.all(promises).then(resolve).catch(reject);\n\t                    })();\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject((0, _error.ensureError)(err));\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop6 = function _loop6(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var direction = options.direction || skladAPI.ASC;\n\t                var range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\t\n\t                var useGetAll = false;\n\t                var iterateRequest = void 0;\n\t\n\t                if (supportsObjStoreGetAll) {\n\t                    // getAll doesn't work for index ranges + it doesn't support special directions\n\t                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n\t                    useGetAll = Object.keys(options).every(function (key) {\n\t                        return key !== 'index' && key !== 'direction';\n\t                    });\n\t                }\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = (0, _error.createError)('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                } else if (useGetAll) {\n\t                    var _ret10 = function () {\n\t                        // If browser supports getAll/getAllKeys methods it could be faster to run these methods\n\t                        // to get all records if there's no `index` or `direction` options set\n\t                        // Unfortunately getAll doesn't expose result keys so we have to run both these methods\n\t                        // to get all keys and values\n\t                        // Anyway it seems like 2 getAll* ops are faster in modern browsers than that one\n\t                        // working with UDBCursor\n\t                        //\n\t                        // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n\t                        // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAllKeys\n\t                        // @see http://jsperf.com/idb-idbcursor-vs-idbobjectstore-getall-ops/3\n\t                        var args = [range];\n\t                        var offset = 0;\n\t\n\t                        if (options.limit) {\n\t                            args.push(options.limit);\n\t\n\t                            if (options.offset) {\n\t                                args[1] += options.offset;\n\t                                offset = options.offset;\n\t                            }\n\t                        }\n\t\n\t                        try {\n\t                            // get all values request\n\t                            objStore.getAll.apply(objStore, args).onsuccess = function (evt) {\n\t                                var values = evt.target.result;\n\t\n\t                                values.forEach(function (value, index) {\n\t                                    if (index < offset) {\n\t                                        return;\n\t                                    }\n\t\n\t                                    var resultIndex = index - offset;\n\t                                    result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n\t                                    result[objStoreName][resultIndex].value = value;\n\t                                });\n\t                            };\n\t\n\t                            // get all keys request\n\t                            objStore.getAllKeys.apply(objStore, args).onsuccess = function (evt) {\n\t                                var keys = evt.target.result;\n\t\n\t                                keys.forEach(function (key, index) {\n\t                                    if (index < offset) {\n\t                                        return;\n\t                                    }\n\t\n\t                                    var resultIndex = index - offset;\n\t                                    result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n\t                                    result[objStoreName][resultIndex].key = key;\n\t                                });\n\t                            };\n\t                        } catch (ex) {\n\t                            abortErr = ex;\n\t                        } finally {\n\t                            // there are 2 separate IDBRequests running\n\t                            // so there's no need to bind listener to success event of any of them\n\t                            return {\n\t                                v: 'continue'\n\t                            };\n\t                        }\n\t                    }();\n\t\n\t                    if ((typeof _ret10 === 'undefined' ? 'undefined' : _typeof(_ret10)) === \"object\") return _ret10.v;\n\t                } else {\n\t                    try {\n\t                        iterateRequest = objStore.openCursor(range, direction);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                }\n\t\n\t                var cursorPositionMoved = false;\n\t\n\t                iterateRequest.onsuccess = function (evt) {\n\t                    var cursor = evt.target.result;\n\t\n\t                    // no more results\n\t                    if (!cursor) {\n\t                        return;\n\t                    }\n\t\n\t                    if (options.offset && !cursorPositionMoved) {\n\t                        cursorPositionMoved = true;\n\t                        cursor.advance(options.offset);\n\t\n\t                        return;\n\t                    }\n\t\n\t                    result[objStoreName].push({\n\t                        key: cursor.key,\n\t                        value: cursor.value\n\t                    });\n\t\n\t                    if (options.limit && options.limit === result[objStoreName].length) {\n\t                        return;\n\t                    }\n\t\n\t                    cursor.continue();\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret9 = _loop6(objStoreName);\n\t\n\t                switch (_ret9) {\n\t                    case 'continue':\n\t                        continue;\n\t\n\t                    default:\n\t                        if ((typeof _ret9 === 'undefined' ? 'undefined' : _typeof(_ret9)) === \"object\") return _ret9.v;\n\t                }\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * 1) Count objects in one object store\n\t     * @param {String} objStoreName name of object store\n\t     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Number} number of stored objects otherwise\n\t     *\n\t     * 2) Count objects in multiple object stores (during one transaction)\n\t     * @param {Object} data\n\t     * @return {Promise}\n\t     *   @param {Error} [err] if promise is rejected\n\t     *   @param {Object} number of stored objects otherwise\n\t     */\n\t    count: function skladConnection_count() {\n\t        var _this6 = this;\n\t\n\t        var isMulti = arguments.length === 1 && _typeof(arguments[0]) === 'object';\n\t        var objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\t        var data = void 0;\n\t\n\t        if (isMulti) {\n\t            data = arguments[0];\n\t        } else {\n\t            data = {};\n\t            data[arguments[0]] = typeof arguments[1] === 'function' ? null : arguments[1];\n\t        }\n\t\n\t        var allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n\t        if (!allObjStoresExist) {\n\t            var err = (0, _error.createError)('NotFoundError', 'Database ' + this.database.name + ' (version ' + this.database.version + ') doesn\\'t contain all needed stores');\n\t            return Promise.reject(err);\n\t        }\n\t\n\t        return new Promise(function (resolve, reject) {\n\t            var result = {};\n\t            var transaction = void 0;\n\t            var countRequest = void 0;\n\t            var abortErr = void 0;\n\t\n\t            // Safari9 can't run multi-objectstore transactions\n\t            // divide one transaction into many with one object store to fix this\n\t            try {\n\t                transaction = _this6.database.transaction(objStoreNames, TRANSACTION_READONLY);\n\t            } catch (ex) {\n\t                if (ex.name === 'NotFoundError') {\n\t                    (function () {\n\t                        var promises = {};\n\t\n\t                        objStoreNames.forEach(function (objStoreName) {\n\t                            var promise = _this6.count(objStoreName, data[objStoreName]);\n\t                            promises[objStoreName] = promise;\n\t                        });\n\t\n\t                        _kinopromise2.default.all(promises).then(resolve).catch(reject);\n\t                    })();\n\t                } else {\n\t                    reject(ex);\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n\t                var err = abortErr || evt.target.error;\n\t                var isSuccess = !err && evt.type === 'complete';\n\t\n\t                if (isSuccess) {\n\t                    resolve(isMulti ? result : result[objStoreNames[0]]);\n\t                } else {\n\t                    reject((0, _error.ensureError)(err));\n\t                }\n\t\n\t                if (evt.type === 'error') {\n\t                    evt.preventDefault();\n\t                }\n\t            };\n\t\n\t            var _loop7 = function _loop7(objStoreName) {\n\t                var objStore = transaction.objectStore(objStoreName);\n\t                var options = data[objStoreName] || {};\n\t                var rangeArgs = options.range instanceof window.IDBKeyRange ? [options.range] : [];\n\t\n\t                if (options.index) {\n\t                    if (!objStore.indexNames.contains(options.index)) {\n\t                        abortErr = (0, _error.createError)('NotFoundError', 'Object store ' + objStore.name + ' doesn\\'t contain \"' + options.index + '\" index');\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t\n\t                    try {\n\t                        var index = objStore.index(options.index);\n\t                        countRequest = index.count.apply(index, rangeArgs);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                } else {\n\t                    try {\n\t                        countRequest = objStore.count.apply(objStore, rangeArgs);\n\t                    } catch (ex) {\n\t                        abortErr = ex;\n\t                        return {\n\t                            v: void 0\n\t                        };\n\t                    }\n\t                }\n\t\n\t                countRequest.onsuccess = function (evt) {\n\t                    result[objStoreName] = evt.target.result || 0;\n\t                };\n\t            };\n\t\n\t            for (var objStoreName in data) {\n\t                var _ret12 = _loop7(objStoreName);\n\t\n\t                if ((typeof _ret12 === 'undefined' ? 'undefined' : _typeof(_ret12)) === \"object\") return _ret12.v;\n\t            }\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Close IndexedDB connection\n\t     */\n\t    close: function skladConnection_close() {\n\t        this.database.close();\n\t        delete this.database;\n\t    }\n\t};\n\t\n\t/**\n\t * Opens connection to a database\n\t *\n\t * @param {String} dbName database name\n\t * @param {Object} [options = {}] connection options\n\t * @param {Number} [options.version] database version\n\t * @param {Object} [options.migration] migration scripts\n\t * @return {Promise}\n\t *   @param {Object} [conn] if - promise is resolved\n\t *   @param {Error} [err] - if promise is rejected\n\t */\n\tskladAPI.open = function sklad_open(dbName) {\n\t    var options = arguments.length <= 1 || arguments[1] === undefined ? { version: 1 } : arguments[1];\n\t\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject((0, _error.createError)('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openConnRequest = window.indexedDB.open(dbName, options.version);\n\t        var isResolvedOrRejected = false;\n\t\n\t        openConnRequest.onupgradeneeded = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            options.migration = options.migration || {};\n\t            for (var i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n\t                if (!options.migration[i]) continue;\n\t\n\t                options.migration[i].call(this, this.result);\n\t            }\n\t        };\n\t\n\t        openConnRequest.onerror = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t            reject((0, _error.ensureError)(evt.target.error));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onsuccess = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            var database = this.result;\n\t            var oldVersion = parseInt(database.version || 0, 10);\n\t\n\t            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n\t                var changeVerRequest = database.setVersion(options.version);\n\t\n\t                changeVerRequest.onsuccess = function (evt) {\n\t                    var customUpgradeNeededEvt = new Event('upgradeneeded');\n\t                    customUpgradeNeededEvt.oldVersion = oldVersion;\n\t                    customUpgradeNeededEvt.newVersion = options.version;\n\t                    openConnRequest.onupgradeneeded.call({ result: evt.target.source }, customUpgradeNeededEvt);\n\t\n\t                    database.close();\n\t                    skladAPI.open(dbName, options).then(resolve, reject);\n\t                };\n\t\n\t                changeVerRequest.onerror = function (evt) {\n\t                    var err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n\t                    reject((0, _error.ensureError)(err));\n\t                };\n\t\n\t                return;\n\t            }\n\t\n\t            // store object stores properties in their own map\n\t            objStoresMeta.set(dbName, new Map());\n\t\n\t            resolve(Object.create(skladConnection, {\n\t                database: {\n\t                    configurable: true,\n\t                    enumerable: false,\n\t                    value: database,\n\t                    writable: false\n\t                }\n\t            }));\n\t\n\t            isResolvedOrRejected = true;\n\t        };\n\t\n\t        openConnRequest.onblocked = function (evt) {\n\t            if (isResolvedOrRejected) {\n\t                return;\n\t            }\n\t\n\t            evt.preventDefault();\n\t\n\t            reject((0, _error.createError)('InvalidStateError', 'Database ' + dbName + ' is blocked'));\n\t            isResolvedOrRejected = true;\n\t        };\n\t    });\n\t};\n\t\n\t/**\n\t * Deletes database\n\t *\n\t * @param {String} dbName\n\t * @return {Promise}\n\t *   @param {Error} [err] if promise is rejected\n\t */\n\tskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n\t    return new Promise(function (resolve, reject) {\n\t        if (!window.indexedDB) {\n\t            reject((0, _error.createError)('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n\t            return;\n\t        }\n\t\n\t        var openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\t\n\t        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n\t            var err = evt.type === 'blocked' ? (0, _error.createError)('InvalidStateError', 'Database ' + dbName + ' is blocked') : evt.target.error;\n\t\n\t            if (err) {\n\t                reject((0, _error.ensureError)(err));\n\t            } else {\n\t                resolve();\n\t            }\n\t\n\t            if (evt.type !== 'success') {\n\t                evt.preventDefault();\n\t            }\n\t        };\n\t    });\n\t};\n\t\n\tskladAPI.keyValue = function sklad_keyValue(key, value) {\n\t    return Object.create(skladKeyValueContainer, {\n\t        key: { value: key, configurable: false, writable: false },\n\t        value: { value: value, configurable: false, writable: false }\n\t    });\n\t};\n\t\n\texports.default = skladAPI;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _toConsumableArray(arr) {\n\t    if (Array.isArray(arr)) {\n\t        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t            arr2[i] = arr[i];\n\t        }return arr2;\n\t    } else {\n\t        return Array.from(arr);\n\t    }\n\t}\n\t\n\tvar KinoPromise = function (_Promise) {\n\t    _inherits(KinoPromise, _Promise);\n\t\n\t    function KinoPromise() {\n\t        _classCallCheck(this, KinoPromise);\n\t\n\t        return _possibleConstructorReturn(this, Object.getPrototypeOf(KinoPromise).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(KinoPromise, [{\n\t        key: 'spread',\n\t        value: function spread(onFulfilled, onRejected) {\n\t            function onFulfilledInternal(res) {\n\t                if (Array.isArray(res)) {\n\t                    return onFulfilled.apply(undefined, _toConsumableArray(res));\n\t                }\n\t            };\n\t\n\t            return this.then(onFulfilledInternal, onRejected);\n\t        }\n\t    }]);\n\t\n\t    return KinoPromise;\n\t}(Promise);\n\t\n\tKinoPromise.all = function KinoPromise_static_all(promises) {\n\t    if (arguments.length > 1 || (typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) !== 'object') {\n\t        return Promise.all.apply(Promise, arguments);\n\t    }\n\t\n\t    return new KinoPromise(function (resolve, reject) {\n\t        var isPromisesList = Array.isArray(promises);\n\t        var promisesArray = void 0;\n\t        var promisesKeys = void 0;\n\t\n\t        if (isPromisesList) {\n\t            promisesArray = promises;\n\t        } else {\n\t            promisesKeys = Object.keys(promises);\n\t            promisesArray = promisesKeys.map(function (key) {\n\t                return promises[key];\n\t            });\n\t        }\n\t\n\t        Promise.all(promisesArray).then(function (res) {\n\t            // transform output into an object\n\t            var output = void 0;\n\t\n\t            if (isPromisesList) {\n\t                output = res;\n\t            } else {\n\t                output = res.reduce(function (output, chunk, index) {\n\t                    output[promisesKeys[index]] = chunk;\n\t                    return output;\n\t                }, {});\n\t            }\n\t\n\t            resolve(output);\n\t        }).catch(reject);\n\t    });\n\t};\n\t\n\texports.default = KinoPromise;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Generates UUIDs for objects without keys set\n\t * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = uuid;\n\tfunction uuid() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t        var r = Math.random() * 16 | 0;\n\t        var v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\n\t        return v.toString(16);\n\t    });\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.createError = createError;\n\texports.ensureError = ensureError;\n\tfunction createError(name, message) {\n\t    var errObj = new Error(message);\n\t    errObj.name = name;\n\t\n\t    return errObj;\n\t}\n\t\n\tfunction ensureError(err) {\n\t    if (err instanceof Error) {\n\t        return err;\n\t    }\n\t\n\t    return createError(err.name, err.message);\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** sklad.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d1da6d9ab6a11d1b2d06\n **/","/**\n * Copyright (c) 2013-2016 Dmitry Sorin <info@staypositive.ru>\n * https://github.com/1999/sklad\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @author Dmitry Sorin <info@staypositive.ru>\n * @license http://www.opensource.org/licenses/mit-license.html MIT License\n */\n'use strict';\n\nimport KinoPromise from 'kinopromise';\nimport uuid from './uuid';\nimport {createError, ensureError} from './error';\n\nif (!window.indexedDB) {\n    window.indexedDB = window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n}\n\nif (!window.IDBTransaction) {\n    window.IDBTransaction = window.mozIDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;\n}\n\nif (!window.IDBKeyRange) {\n    window.IDBKeyRange = window.mozIDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;\n}\n\nif (!window.IDBCursor) {\n    window.IDBCursor = window.mozIDBCursor || window.webkitIDBCursor || window.msIDBCursor;\n}\n\nconst TRANSACTION_READONLY = window.IDBTransaction.READ_ONLY || 'readonly';\nconst TRANSACTION_READWRITE = window.IDBTransaction.READ_WRITE || 'readwrite';\n\nconst skladAPI = {};\nskladAPI.ASC = window.IDBCursor.NEXT || 'next';\nskladAPI.ASC_UNIQUE = window.IDBCursor.NEXT_NO_DUPLICATE || 'nextunique';\nskladAPI.DESC = window.IDBCursor.PREV || 'prev';\nskladAPI.DESC_UNIQUE = window.IDBCursor.PREV_NO_DUPLICATE || 'prevunique';\n\n// unfortunately `babel-plugin-array-includes` can't convert Array.prototype.includes\n// into Array.prototype.indexOf with its code\nconst indexOf = Array.prototype.indexOf;\nconst supportsObjStoreGetAll = typeof IDBObjectStore.prototype.getAll === 'function' && typeof IDBObjectStore.prototype.getAllKeys === 'function';\nconst objStoresMeta = new Map();\n\n/**\n * Common ancestor for objects created with sklad.keyValue() method\n * Used to distinguish standard objects with \"key\" and \"value\" fields from special ones\n */\nconst skladKeyValueContainer = Object.create(null);\n\n/**\n * Checks data before saving it in the object store\n * @return {Boolean} false if saved data type is incorrect, otherwise {Array} object store function arguments\n */\nfunction checkSavedData(dbName, objStore, data) {\n    const keyValueContainer = Object.prototype.isPrototypeOf.call(skladKeyValueContainer, data);\n    const value = keyValueContainer ? data.value : data;\n    const objStoreMeta = objStoresMeta.get(dbName).get(objStore.name);\n    let key = keyValueContainer ? data.key : undefined;\n\n    const keyPath = objStore.keyPath || objStoreMeta.keyPath;\n    const autoIncrement = objStore.autoIncrement || objStoreMeta.autoIncrement;\n\n    if (keyPath === null) {\n        if (!autoIncrement && key === undefined) {\n            key = uuid();\n        }\n    } else {\n        if (typeof data !== 'object') {\n            return false;\n        }\n\n        // TODO: support dot-separated and array keyPaths\n        if (!autoIncrement && data[keyPath] === undefined) {\n            data[keyPath] = uuid();\n        }\n    }\n\n    return key ? [value, key] : [value];\n}\n\n/**\n * Check whether database contains all needed stores\n *\n * @param {Array<String>} objStoreNames\n * @return {Boolean}\n */\nfunction checkContainingStores(objStoreNames) {\n    return objStoreNames.every(function (storeName) {\n        return (indexOf.call(this.database.objectStoreNames, storeName) !== -1);\n    }, this);\n}\n\n/**\n * autoIncrement is broken in IE family. Run this transaction to get its value\n * on every object store\n *\n * @param {IDBDatabase} db\n * @param {Array<String>} objStoreNames\n * @return {Promise}\n *\n * @see http://stackoverflow.com/questions/35682165/indexeddb-in-ie11-edge-why-is-objstore-autoincrement-undefined\n * @see https://connect.microsoft.com/IE/Feedback/Details/772726\n */\nfunction getObjStoresMeta(db, objStoreNames) {\n    const dbMeta = objStoresMeta.get(db.name);\n    const promises = [];\n\n    objStoreNames.forEach(objStoreName => {\n        if (dbMeta.has(objStoreName)) {\n            return;\n        }\n\n        const promise = new Promise(resolve => {\n            const transaction = db.transaction([objStoreName], TRANSACTION_READWRITE);\n            transaction.oncomplete = resolve;\n            transaction.onabort = resolve;\n\n            const objStore = transaction.objectStore(objStoreName);\n\n            if (objStore.autoIncrement !== undefined) {\n                dbMeta.set(objStoreName, {\n                    autoIncrement: objStore.autoIncrement,\n                    keyPath: objStore.keyPath\n                });\n\n                return;\n            }\n\n            let autoIncrement;\n\n            if (objStore.keyPath !== null) {\n                // if key path is defined it's possible to insert only objects\n                // but if key generator (autoIncrement) is not defined the inserted objects\n                // must contain field(s) described in keyPath value otherwise IDBObjectStore.add op fails\n                // so if we run ODBObjectStore.add with an empty object and it fails, this means that\n                // autoIncrement property was false. Otherwise - true\n                // if key path is array autoIncrement property can't be true\n                if (Array.isArray(objStore.keyPath)) {\n                    autoIncrement = false;\n                } else {\n                    try {\n                        objStore.add({});\n                        autoIncrement = true;\n                    } catch (ex) {\n                        autoIncrement = false;\n                    }\n                }\n            } else {\n                // if key path is not defined it's possible to insert any kind of data\n                // but if key generator (autoIncrement) is not defined you should set it explicitly\n                // so if we run ODBObjectStore.add with one argument and it fails, this means that\n                // autoIncrement property was false. Otherwise - true\n                try {\n                    objStore.add('some value');\n                    autoIncrement = true;\n                } catch (ex) {\n                    autoIncrement = false;\n                }\n            }\n\n            // save meta properties\n            dbMeta.set(objStoreName, {\n                autoIncrement: autoIncrement,\n                keyPath: objStore.keyPath\n            });\n\n            // and abort transaction so that new record is forgotten\n            transaction.abort();\n        });\n\n        promises.push(promise);\n    });\n\n    return Promise.all(promises);\n}\n\nconst skladConnection = {\n    /**\n     * 1) Insert one record into the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {*} inserted object key\n     *\n     * 2) Insert multiple records into the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} inserted objects' keys\n     */\n    insert: function skladConnection_insert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return getObjStoresMeta(this.database, objStoreNames).then(() => {\n            return new Promise((resolve, reject) => {\n                const result = {};\n                let transaction;\n                let abortErr;\n\n                // Safari9 can't run multi-objectstore transactions\n                // divide one transaction into many with one object store to fix this\n                try {\n                    transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n                } catch (ex) {\n                    if (ex.name === 'NotFoundError') {\n                        const promises = {};\n\n                        objStoreNames.forEach(objStoreName => {\n                            const promise = this.insert({\n                                [objStoreName]: Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]]\n                            }).then(res => res[objStoreName]);\n\n                            promises[objStoreName] = promise;\n                        });\n\n                        KinoPromise.all(promises).then(resolve).catch(reject);\n                    } else {\n                        reject(ex);\n                    }\n\n                    return;\n                }\n\n                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_insert_onFinish(evt) {\n                    const err = abortErr || evt.target.error;\n                    const isSuccess = !err && evt.type === 'complete';\n\n                    if (isSuccess) {\n                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                    } else {\n                        reject(ensureError(err));\n                    }\n\n                    if (evt.type === 'error') {\n                        evt.preventDefault();\n                    }\n                };\n\n                for (let objStoreName in data) {\n                    const objStore = transaction.objectStore(objStoreName);\n\n                    for (let i = 0; i < data[objStoreName].length; i++) {\n                        const checkedData = checkSavedData(this.database.name, objStore, data[objStoreName][i]);\n\n                        if (!checkedData) {\n                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                            return;\n                        }\n\n                        let req;\n                        try {\n                            req = objStore.add.apply(objStore, checkedData);\n                        } catch (ex) {\n                            abortErr = ex;\n                            continue;\n                        }\n\n                        req.onsuccess = function (evt) {\n                            result[objStoreName] = result[objStoreName] || [];\n                            result[objStoreName][i] = evt.target.result;\n                        };\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Insert or update one record in the object store\n     * @param {String} objStoreName name of object store\n     * @param {*} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {*} inserted/updated object key otherwise\n     *\n     * 2) Insert or update multiple records in the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} inserted/updated objects' keys otherwise\n     */\n    upsert: function skladConnection_upsert() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return getObjStoresMeta(this.database, objStoreNames).then(() => {\n            return new Promise((resolve, reject) => {\n                const result = {};\n                let transaction;\n                let abortErr;\n\n                // Safari9 can't run multi-objectstore transactions\n                // divide one transaction into many with one object store to fix this\n                try {\n                    transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n                } catch (ex) {\n                    if (ex.name === 'NotFoundError') {\n                        const promises = {};\n\n                        objStoreNames.forEach(objStoreName => {\n                            const promise = this.upsert({\n                                [objStoreName]: Array.isArray(data[objStoreName]) ? data[objStoreName] : [data[objStoreName]]\n                            }).then(res => res[objStoreName]);\n\n                            promises[objStoreName] = promise;\n                        });\n\n                        KinoPromise.all(promises).then(resolve).catch(reject);\n                    } else {\n                        reject(ex);\n                    }\n\n                    return;\n                }\n\n                transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_upsert_onFinish(evt) {\n                    const err = abortErr || evt.target.error;\n                    const isSuccess = !err && evt.type === 'complete';\n\n                    if (isSuccess) {\n                        resolve(isMulti ? result : result[objStoreNames[0]][0]);\n                    } else {\n                        reject(ensureError(err));\n                    }\n\n                    if (evt.type === 'error') {\n                        evt.preventDefault();\n                    }\n                };\n\n                for (let objStoreName in data) {\n                    const objStore = transaction.objectStore(objStoreName);\n\n                    for (let i = 0; i < data[objStoreName].length; i++) {\n                        const checkedData = checkSavedData(this.database.name, objStore, data[objStoreName][i]);\n\n                        if (!checkedData) {\n                            abortErr = createError('InvalidStateError', 'You must supply objects to be saved in the object store with set keyPath');\n                            return;\n                        }\n\n                        let req;\n                        try {\n                            req = objStore.put.apply(objStore, checkedData);\n                        } catch (ex) {\n                            abortErr = ex;\n                            continue;\n                        }\n\n                        req.onsuccess = function (evt) {\n                            result[objStoreName] = result[objStoreName] || [];\n                            result[objStoreName][i] = evt.target.result;\n                        };\n                    }\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Delete one record from the object store\n     * @param {String} objStoreName name of object store\n     * @param {Mixed} key\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *\n     * 2) Delete multiple records from the object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *\n     * ATTENTION: you can pass only VALID KEYS OR KEY RANGES to delete records\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-valid-key\n     * @see https://dvcs.w3.org/hg/IndexedDB/raw-file/tip/Overview.html#dfn-key-range\n     */\n    delete: function skladConnection_delete() {\n        const isMulti = (arguments.length === 1);\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let data;\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = [arguments[1]];\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = objStoreNames.map(objStoreName => this.delete(objStoreName, data[objStoreName]));\n                    Promise.all(promises).then(() => resolve()).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_delete_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(ensureError(err));\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n\n                data[objStoreName].forEach(recordKey => {\n                    if (abortErr) {\n                        return;\n                    }\n\n                    try {\n                        objStore.delete(recordKey);\n                    } catch (ex) {\n                        abortErr = ex;\n                    }\n                });\n            }\n        });\n    },\n\n    /**\n     * Clear object store(s)\n     *\n     * @param {Array|String} objStoreNames array of object stores or a single object store\n     * @return {Promise}\n     *   @param {Error} err\n     */\n    clear: function skladConnection_clear(objStoreNames) {\n        objStoreNames = Array.isArray(objStoreNames) ? objStoreNames : [objStoreNames];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READWRITE);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = objStoreNames.map(objStoreName => this.clear([objStoreName]));\n                    Promise.all(promises).then(() => resolve()).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_clear_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n\n                if (err) {\n                    reject(ensureError(err));\n                } else {\n                    resolve();\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            objStoreNames.forEach(objStoreName => {\n                const objStore = transaction.objectStore(objStoreName);\n\n                if (abortErr) {\n                    return;\n                }\n\n                try {\n                    objStore.clear();\n                } catch (ex) {\n                    abortErr = ex;\n                }\n            });\n        });\n    },\n\n    /**\n     * 1) Get objects from one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index', 'range', 'offset', 'limit' and 'direction'\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Array} stored objects otherwise\n     *\n     * 2) Get objects from multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} stored objects otherwise\n     */\n    get: function skladConnection_get() {\n        const isMulti = (arguments.length === 1 && typeof arguments[0] === 'object');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        let result = {};\n        let data, abortErr;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = arguments[1];\n        }\n\n        objStoreNames.forEach(function (objStoreName) {\n            result[objStoreName] = [];\n        });\n\n        return new Promise((resolve, reject) => {\n            let transaction;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = {};\n\n                    objStoreNames.forEach(objStoreName => {\n                        const promise = this.get(objStoreName, data[objStoreName]);\n                        promises[objStoreName] = promise;\n                    });\n\n                    KinoPromise.all(promises).then(resolve).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_get_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]]);\n                } else {\n                    reject(ensureError(err));\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const direction = options.direction || skladAPI.ASC;\n                const range = options.range instanceof window.IDBKeyRange ? options.range : null;\n\n                let useGetAll = false;\n                let iterateRequest;\n\n                if (supportsObjStoreGetAll) {\n                    // getAll doesn't work for index ranges + it doesn't support special directions\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    useGetAll = Object.keys(options).every(key => (key !== 'index' && key !== 'direction'));\n                }\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        iterateRequest = objStore.index(options.index).openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else if (useGetAll) {\n                    // If browser supports getAll/getAllKeys methods it could be faster to run these methods\n                    // to get all records if there's no `index` or `direction` options set\n                    // Unfortunately getAll doesn't expose result keys so we have to run both these methods\n                    // to get all keys and values\n                    // Anyway it seems like 2 getAll* ops are faster in modern browsers than that one\n                    // working with UDBCursor\n                    //\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n                    // @see https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAllKeys\n                    // @see http://jsperf.com/idb-idbcursor-vs-idbobjectstore-getall-ops/3\n                    const args = [range];\n                    let offset = 0;\n\n                    if (options.limit) {\n                        args.push(options.limit);\n\n                        if (options.offset) {\n                            args[1] += options.offset;\n                            offset = options.offset;\n                        }\n                    }\n\n                    try {\n                        // get all values request\n                        objStore.getAll(...args).onsuccess = function (evt) {\n                            const values = evt.target.result;\n\n                            values.forEach((value, index) => {\n                                if (index < offset) {\n                                    return;\n                                }\n\n                                const resultIndex = index - offset;\n                                result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n                                result[objStoreName][resultIndex].value = value;\n                            });\n                        };\n\n                        // get all keys request\n                        objStore.getAllKeys(...args).onsuccess = function (evt) {\n                            const keys = evt.target.result;\n\n                            keys.forEach((key, index) => {\n                                if (index < offset) {\n                                    return;\n                                }\n\n                                const resultIndex = index - offset;\n                                result[objStoreName][resultIndex] = result[objStoreName][resultIndex] || {};\n                                result[objStoreName][resultIndex].key = key;\n                            });\n                        };\n                    } catch (ex) {\n                        abortErr = ex;\n                    } finally {\n                        // there are 2 separate IDBRequests running\n                        // so there's no need to bind listener to success event of any of them\n                        continue;\n                    }\n                } else {\n                    try {\n                        iterateRequest = objStore.openCursor(range, direction);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                let cursorPositionMoved = false;\n\n                iterateRequest.onsuccess = function (evt) {\n                    const cursor = evt.target.result;\n\n                    // no more results\n                    if (!cursor) {\n                        return;\n                    }\n\n                    if (options.offset && !cursorPositionMoved) {\n                        cursorPositionMoved = true;\n                        cursor.advance(options.offset);\n\n                        return;\n                    }\n\n                    result[objStoreName].push({\n                        key: cursor.key,\n                        value: cursor.value\n                    });\n\n                    if (options.limit && options.limit === result[objStoreName].length) {\n                        return;\n                    }\n\n                    cursor.continue();\n                };\n            }\n        });\n    },\n\n    /**\n     * 1) Count objects in one object store\n     * @param {String} objStoreName name of object store\n     * @param {Object} options (optional) object with keys 'index' or/and 'range'\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Number} number of stored objects otherwise\n     *\n     * 2) Count objects in multiple object stores (during one transaction)\n     * @param {Object} data\n     * @return {Promise}\n     *   @param {Error} [err] if promise is rejected\n     *   @param {Object} number of stored objects otherwise\n     */\n    count: function skladConnection_count() {\n        const isMulti = (arguments.length === 1 && typeof arguments[0] === 'object');\n        const objStoreNames = isMulti ? Object.keys(arguments[0]) : [arguments[0]];\n        let data;\n\n        if (isMulti) {\n            data = arguments[0];\n        } else {\n            data = {};\n            data[arguments[0]] = (typeof arguments[1] === 'function') ? null : arguments[1];\n        }\n\n        const allObjStoresExist = checkContainingStores.call(this, objStoreNames);\n        if (!allObjStoresExist) {\n            const err = createError('NotFoundError', `Database ${this.database.name} (version ${this.database.version}) doesn't contain all needed stores`);\n            return Promise.reject(err);\n        }\n\n        return new Promise((resolve, reject) => {\n            const result = {};\n            let transaction;\n            let countRequest;\n            let abortErr;\n\n            // Safari9 can't run multi-objectstore transactions\n            // divide one transaction into many with one object store to fix this\n            try {\n                transaction = this.database.transaction(objStoreNames, TRANSACTION_READONLY);\n            } catch (ex) {\n                if (ex.name === 'NotFoundError') {\n                    const promises = {};\n\n                    objStoreNames.forEach(objStoreName => {\n                        const promise = this.count(objStoreName, data[objStoreName]);\n                        promises[objStoreName] = promise;\n                    });\n\n                    KinoPromise.all(promises).then(resolve).catch(reject);\n                } else {\n                    reject(ex);\n                }\n\n                return;\n            }\n\n            transaction.oncomplete = transaction.onerror = transaction.onabort = function skladConnection_count_onFinish(evt) {\n                const err = abortErr || evt.target.error;\n                const isSuccess = !err && evt.type === 'complete';\n\n                if (isSuccess) {\n                    resolve(isMulti ? result : result[objStoreNames[0]])\n                } else {\n                    reject(ensureError(err));\n                }\n\n                if (evt.type === 'error') {\n                    evt.preventDefault();\n                }\n            };\n\n            for (let objStoreName in data) {\n                const objStore = transaction.objectStore(objStoreName);\n                const options = data[objStoreName] || {};\n                const rangeArgs = (options.range instanceof window.IDBKeyRange) ? [options.range] : [];\n\n                if (options.index) {\n                    if (!objStore.indexNames.contains(options.index)) {\n                        abortErr = createError('NotFoundError', `Object store ${objStore.name} doesn't contain \"${options.index}\" index`);\n                        return;\n                    }\n\n                    try {\n                        const index = objStore.index(options.index);\n                        countRequest = index.count(...rangeArgs);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                } else {\n                    try {\n                        countRequest = objStore.count(...rangeArgs);\n                    } catch (ex) {\n                        abortErr = ex;\n                        return;\n                    }\n                }\n\n                countRequest.onsuccess = function (evt) {\n                    result[objStoreName] = evt.target.result || 0;\n                };\n            }\n        });\n    },\n\n    /**\n     * Close IndexedDB connection\n     */\n    close: function skladConnection_close() {\n        this.database.close();\n        delete this.database;\n    }\n};\n\n/**\n * Opens connection to a database\n *\n * @param {String} dbName database name\n * @param {Object} [options = {}] connection options\n * @param {Number} [options.version] database version\n * @param {Object} [options.migration] migration scripts\n * @return {Promise}\n *   @param {Object} [conn] if - promise is resolved\n *   @param {Error} [err] - if promise is rejected\n */\nskladAPI.open = function sklad_open(dbName, options = {version: 1}) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openConnRequest = window.indexedDB.open(dbName, options.version);\n        let isResolvedOrRejected = false;\n\n        openConnRequest.onupgradeneeded = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            options.migration = options.migration || {};\n            for (let i = evt.oldVersion + 1; i <= evt.newVersion; i++) {\n                if (!options.migration[i])\n                    continue;\n\n                options.migration[i].call(this, this.result);\n            }\n        };\n\n        openConnRequest.onerror = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n            reject(ensureError(evt.target.error));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onsuccess = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            const database = this.result;\n            const oldVersion = parseInt(database.version || 0, 10);\n\n            if (typeof database.setVersion === 'function' && oldVersion < options.version) {\n                const changeVerRequest = database.setVersion(options.version);\n\n                changeVerRequest.onsuccess = function (evt) {\n                    const customUpgradeNeededEvt = new Event('upgradeneeded');\n                    customUpgradeNeededEvt.oldVersion = oldVersion;\n                    customUpgradeNeededEvt.newVersion = options.version;\n                    openConnRequest.onupgradeneeded.call({result: evt.target.source}, customUpgradeNeededEvt);\n\n                    database.close();\n                    skladAPI.open(dbName, options).then(resolve, reject);\n                };\n\n                changeVerRequest.onerror = function (evt) {\n                    const err = evt.target.errorMessage || evt.target.webkitErrorMessage || evt.target.mozErrorMessage || evt.target.msErrorMessage || evt.target.error.name;\n                    reject(ensureError(err));\n                };\n\n                return;\n            }\n\n            // store object stores properties in their own map\n            objStoresMeta.set(dbName, new Map());\n\n            resolve(Object.create(skladConnection, {\n                database: {\n                    configurable: true,\n                    enumerable: false,\n                    value: database,\n                    writable: false\n                }\n            }));\n\n            isResolvedOrRejected = true;\n        };\n\n        openConnRequest.onblocked = function (evt) {\n            if (isResolvedOrRejected) {\n                return;\n            }\n\n            evt.preventDefault();\n\n            reject(createError('InvalidStateError', `Database ${dbName} is blocked`));\n            isResolvedOrRejected = true;\n        };\n    });\n};\n\n/**\n * Deletes database\n *\n * @param {String} dbName\n * @return {Promise}\n *   @param {Error} [err] if promise is rejected\n */\nskladAPI.deleteDatabase = function sklad_deleteDatabase(dbName) {\n    return new Promise((resolve, reject) => {\n        if (!window.indexedDB) {\n            reject(createError('NotSupportedError', 'Your browser doesn\\'t support IndexedDB'));\n            return;\n        }\n\n        const openDbRequest = window.indexedDB.deleteDatabase(dbName);\n\n        openDbRequest.onsuccess = openDbRequest.onerror = openDbRequest.onblocked = function sklad_deleteDatabase_onFinish(evt) {\n            const err = (evt.type === 'blocked')\n                ? createError('InvalidStateError', `Database ${dbName} is blocked`)\n                : evt.target.error;\n\n            if (err) {\n                reject(ensureError(err));\n            } else {\n                resolve();\n            }\n\n            if (evt.type !== 'success') {\n                evt.preventDefault();\n            }\n        };\n    });\n};\n\nskladAPI.keyValue = function sklad_keyValue(key, value) {\n    return Object.create(skladKeyValueContainer, {\n        key: {value: key, configurable: false, writable: false},\n        value: {value: value, configurable: false, writable: false}\n    });\n};\n\nexport default skladAPI;\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/sklad.js\n **/","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }\n\nclass KinoPromise extends Promise {\n    spread(onFulfilled, onRejected) {\n        function onFulfilledInternal(res) {\n            if (Array.isArray(res)) {\n                return onFulfilled.apply(undefined, _toConsumableArray(res));\n            }\n        };\n\n        return this.then(onFulfilledInternal, onRejected);\n    }\n}\n\nKinoPromise.all = function KinoPromise_static_all(promises) {\n    if (arguments.length > 1 || typeof promises !== 'object') {\n        return Promise.all.apply(Promise, arguments);\n    }\n\n    return new KinoPromise((resolve, reject) => {\n        const isPromisesList = Array.isArray(promises);\n        let promisesArray;\n        let promisesKeys;\n\n        if (isPromisesList) {\n            promisesArray = promises;\n        } else {\n            promisesKeys = Object.keys(promises);\n            promisesArray = promisesKeys.map(key => promises[key]);\n        }\n\n        Promise.all(promisesArray).then(res => {\n            // transform output into an object\n            let output;\n\n            if (isPromisesList) {\n                output = res;\n            } else {\n                output = res.reduce((output, chunk, index) => {\n                    output[promisesKeys[index]] = chunk;\n                    return output;\n                }, {});\n            }\n\n            resolve(output);\n        }).catch(reject);\n    });\n};\n\nexports.default = KinoPromise;\nmodule.exports = exports['default'];\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/kinopromise/build.js\n **/","'use strict';\n\n/**\n * Generates UUIDs for objects without keys set\n * @link http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n */\nexport default function uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0;\n        const v = (c === 'x') ? r : (r&0x3|0x8);\n\n        return v.toString(16);\n    });\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/uuid.js\n **/","'use strict';\n\nexport function createError(name, message) {\n    const errObj = new Error(message);\n    errObj.name = name;\n\n    return errObj;\n}\n\nexport function ensureError(err) {\n    if (err instanceof Error) {\n        return err;\n    }\n\n    return createError(err.name, err.message);\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./lib/error.js\n **/"],"sourceRoot":""}